{"version":3,"sources":["felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractMagicEdgeTypeSubscriber.js"],"names":["_utils","require","_Edge","_exception","_AbstractRefEdgeTypeSubscriber","AbstractMagicEdgeTypeSubscriber","allEdgeTypes","options","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","edgeTypesByFieldName","_utils2","default","makeHashMap","id","edgeType","canHandle","name","tObj","fieldName","toWL","MissingOverrideError","refsGroupedByType","fieldNames","fields","type","typeWL","toRefs","getReferencesFromField","length"],"mappings":"oVAWA,IAAAA,QAAAC,QAAA,wFACA,IAAAC,OAAAD,QAAA,qFACA,IAAAE,YAAAF,QAAA,iDACA,IAAAG,gCAAAH,QAAA;;;;;;;;;;GAKMI,2DAKJ,SAAAA,GAAYC,EAAcC,GAASC,gBAAAC,KAAAJ,EAAA,IAAAK,GAAAC,2BAAAF,MAAAJ,EAAAO,WAAAC,OAAAC,eAAAT,IAAAU,KAAAN,KAE3BH,EAAcC,GAzBxBG,GAAAM,qBAAAC,QAAAC,QAAAC,aA8BI,KAAK,GAAIC,KAAMd,GAAc,CAE3B,GAAMe,GAAWf,EAAac,EAC9B,IAAIV,EAAKY,UAAUD,GAAW,CAC5BX,EAAKM,qBAAqBK,EAASE,MAAQF,GAXd,MAAAX,kEAIjCc,EAAAC,EAAAC,GAyBA,KAAM,IAAAvB,YAAAwB,qBAAyBlB,KAAM,kEAlB5BO,EAAAA,EAAAA,GAER,GAAAY,GAAAX,QAAAC,QAAAC,aA0BD,IAAMU,GAAaL,EAAKM,MAxBzB,KAAA,GAAAL,KAAAI,GAAA,CA6BG,GAAME,GAAOtB,KAAKO,qBAAqBS,EAEvC,KAAKM,GAASC,IAAWA,EAAOD,EAAKX,IAAM,QAG3C,IAAMa,GAASxB,KAAKyB,uBAAuBV,EAAMC,EAAWC,EAE5D,IAAIO,GAAUA,EAAOE,OAAQ,CAC3BP,EAAkBG,EAAKX,IAAMa,GAKjC,MAAOL,0EAOIvB","file":"../../../../../felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractMagicEdgeTypeSubscriber.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport Edge from '$:/plugins/felixhayashi/tiddlymap/js/Edge';\nimport { MissingOverrideError } from '$:/plugins/felixhayashi/tiddlymap/js/exception';\nimport AbstractRefEdgeTypeSubscriber from '$:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber';\n\n/**\n * @constructor\n */\nclass AbstractMagicEdgeTypeSubscriber extends AbstractRefEdgeTypeSubscriber {\n\n  /**\n   * @inheritDoc\n   */\n  constructor(allEdgeTypes, options) {\n\n    super(allEdgeTypes, options);\n\n    // later used for edge retrieval to identify those fields that hold connections\n    this.edgeTypesByFieldName = utils.makeHashMap();\n\n    for (let id in allEdgeTypes) {\n\n      const edgeType = allEdgeTypes[id];\n      if (this.canHandle(edgeType)) {\n        this.edgeTypesByFieldName[edgeType.name] = edgeType;\n      }\n    }\n\n  }\n\n  /**\n   * Returns all references to other tiddlers stored in the specified tiddler.\n   *\n   * @interface\n   * @param {Tiddler} tObj - the tiddler that holds the references.\n   * @param {String} fieldName - the name of the field to get the reference from.\n   * @param {Object<TiddlerReference, boolean>} toWL - a whitelist of tiddlers that are allowed to\n   *     be included in the result.\n   * @return {Object<Id, Edge>|null}\n   */\n  getReferencesFromField(tObj, fieldName, toWL) {\n\n    throw new MissingOverrideError(this, 'getReferencesFromField');\n\n  };\n\n  /**\n   * @inheritDoc\n   */\n  getReferences(tObj, toWL, typeWL) {\n\n    const refsGroupedByType = utils.makeHashMap();\n    const fieldNames = tObj.fields;\n\n    for (let fieldName in fieldNames) {\n\n\n      const type = this.edgeTypesByFieldName[fieldName];\n\n      if (!type || (typeWL && !typeWL[type.id])) continue;\n\n\n      const toRefs = this.getReferencesFromField(tObj, fieldName, toWL);\n\n      if (toRefs && toRefs.length) {\n        refsGroupedByType[type.id] = toRefs;\n      }\n\n    }\n\n    return refsGroupedByType;\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport default AbstractMagicEdgeTypeSubscriber;\n"],"sourceRoot":"../../../../../../src/plugins"}