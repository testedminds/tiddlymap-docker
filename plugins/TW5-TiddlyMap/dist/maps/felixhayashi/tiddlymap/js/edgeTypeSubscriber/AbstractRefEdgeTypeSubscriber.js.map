{"version":3,"sources":["felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractRefEdgeTypeSubscriber.js"],"names":["_utils","require","_Edge","_exception","_AbstractEdgeTypeSubscriber","AbstractRefEdgeTypeSubscriber","tObj","toWL","typeWL","refsByType","this","getReferences","_utils2","default","hasElements","fromId","fields","idByT","$tm","tracker","getIdsByTiddlers","allETy","allEdgeTypes","fromTRef","getTiddlerRef","edges","makeHashMap","typeId","toRefs","type","i","length","toTRef","$tw","wiki","tiddlerExists","isSystemOrDraft","id","utils","hashString","_Edge2","MissingOverrideError"],"mappings":"oVAaA,IAAAA,QAAAC,QAAA,wFACA,IAAAC,OAAAD,QAAA,qFACA,IAAAE,YAAAF,QAAA,iDAAA,IAAAG,6BAAAH,QAAA;;;;;;;;;;GAUMI,uPAKMC,EAAMC,EAAMC,GAGpB,GAAMC,GAAaC,KAAKC,cAAcL,EAAMC,EAAMC,EAElD,KAAKC,IAAeG,QAAAC,QAAMC,YAAYL,GAAa,MAEnD,IAAMM,GAAST,EAAKU,OAAO,UAC3B,IAAMC,GAAQC,IAAIC,QAAQC,kBA3B9B,IAAAC,GAAAX,KAAAY,YA6BI,IAAMC,GAAWX,QAAAC,QAAMW,cAAclB,EAErC,IAAMmB,GAAQb,QAAAC,QAAMa,aAEpB,KAAK,GAAIC,KAAUlB,GAAY,CAE7B,GAAMmB,GAASnB,EAAWkB,EArB1BtB,KAAAA,EAAAA,CAwBE,SAGF,GAAMwB,GAAOR,EAAOM,EACpB,KAAK,GAAIG,GAAIF,EAAOG,OAAQD,KAAM,CAChC,GAAME,GAASJ,EAAOE,EAEtB,KAAKE,IACCC,IAAIC,KAAKC,cAAcH,IACxBpB,QAAAC,QAAMuB,gBAAgBJ,IACrBzB,IAASA,EAAKyB,GAAU,CAC5B,SAGF,GAAMK,GAAKR,EAAKQ,GAAKJ,IAAIK,MAAMC,WAAWhB,EAAWS,EACrDP,GAAMY,GAAM,GAAAG,QAAA3B,QAASE,EAlCXR,EAAMC,GAAQqB,EAAAQ,GAAAA,IAsC5B,MAAOZ,2CAlBJnB,EAAAC,EAAAC,GAED,KAAA,IAAAL,YAAAsC,qBAAA/B,KAAA,qFAyCSL","file":"../../../../../felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractRefEdgeTypeSubscriber.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport Edge from '$:/plugins/felixhayashi/tiddlymap/js/Edge';\nimport { MissingOverrideError } from '$:/plugins/felixhayashi/tiddlymap/js/exception';\nimport AbstractEdgeTypeSubscriber from '$:/plugins/felixhayashi/tiddlymap/js/AbstractEdgeTypeSubscriber';\n\n/*** Code **********************************************************/\n\n/**\n * Parent class for all subscribers that retrieve or store\n * non-TiddlyMap edges ({@see TmapEdgeTypeSubscriber) from a tiddler,\n * for example tag or list references.\n */\nclass AbstractRefEdgeTypeSubscriber extends AbstractEdgeTypeSubscriber {\n\n  /**\n   * @inheritDoc\n   */\n  loadEdges(tObj, toWL, typeWL) {\n\n    // references to other tiddlers grouped by their edge type\n    const refsByType = this.getReferences(tObj, toWL, typeWL);\n\n    if (!refsByType || !utils.hasElements(refsByType)) return;\n\n    const fromId = tObj.fields['tmap.id'];\n    const idByT = $tm.tracker.getIdsByTiddlers();\n    const allETy = this.allEdgeTypes;\n    const fromTRef = utils.getTiddlerRef(tObj);\n\n    const edges = utils.makeHashMap();\n\n    for (let typeId in refsByType) {\n\n      const toRefs = refsByType[typeId];\n\n      if (!toRefs) {\n        continue;\n      }\n\n      const type = allETy[typeId];\n      for (let i = toRefs.length; i--;) {\n        const toTRef = toRefs[i];\n\n        if (!toTRef\n          || !$tw.wiki.tiddlerExists(toTRef)\n          || utils.isSystemOrDraft(toTRef)\n          || (toWL && !toWL[toTRef])) {\n          continue;\n        }\n\n        const id = type.id + $tw.utils.hashString(fromTRef + toTRef);\n        edges[id] = new Edge(fromId, idByT[toTRef], type.id, id);\n      }\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * Returns a list of tiddlers (= tiddler names) that are targeted by the specified tiddler.\n   * Note: All referenced tiddlers have to be grouped by their edge type.\n   *\n   * @interface\n   * @param {Tiddler} tObj - the tiddler that holds the references.\n   * @param {Object<TiddlerReference, boolean>} toWL - a whitelist of tiddlers that are allowed to\n   *     be included in the result.\n   * @param {Object<id, EdgeType>} typeWL - a whitelist that defines that only Tiddlers that are linked\n   *     via a type specified in the list may be included in the result.\n   * @return {Object<string, TiddlerReference[]>|null} a list of referenced tiddlers grouped by their edge type.\n   */\n  getReferences(tObj, toWL, typeWL) {\n\n    throw new MissingOverrideError(this, 'getReferences');\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport default AbstractRefEdgeTypeSubscriber;\n"],"sourceRoot":"../../../../../../src/plugins"}