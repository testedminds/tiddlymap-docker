{"version":3,"sources":["felixhayashi/tiddlymap/js/edgeTypeSubscriber/EdgeTypeSubscriberRegistry.js"],"names":["EdgeTypeSubscriberRegistry","subscribers","allEdgeTypes","tracker","_classCallCheck","this","subscriberClasses","updateIndex","edgeType","allSubscribers","subscribersForType","i","l","length","canHandle","push","skipOthers","subscriberClass","moduleName","subscriber","setTracker","ignore","s2","priority","s1"],"mappings":";;;;;;;;;;;GAeMA,uCAOJ,QAAAA,GAAYC,EAAaC,EAAcC,GAASC,gBAAAC,KAAAL,EAE9CK,MAAKC,kBAAoBL,CATvBD,MAAAA,QAAAA,CAEJK,MAAAE,YAAAL,yDAoBcM,GARb,GAAAC,GAAAJ,KAAAI,cAWC,IAAMC,KAEN,KAAK,GAAIC,GAAI,EAAGC,EAAIH,EAAeI,OAAQF,EAAIC,EAAGD,IAAK,CAErD,GAAIF,EAAeE,GAAGG,UAAUN,GAAW,CAEzCE,EAAmBK,KAAKN,EAAeE,GAEvC,IAAIF,EAAeE,GAAGK,WAAY,CAChC,QATN,MAAMN,sCAWH,MAAAL,MAAAI,qDA2BOP,GAEV,GAAMO,KAGN,IAAMQ,GAAkBZ,KAAKC,iBAd/B,KAAA,GAAAY,KAAAD,GAAA,CAiBI,GAAME,GAAa,GAAKF,GAAgBC,GAAahB,EACrDiB,GAAWC,WAAWf,KAAKF,QAG3B,IAAIgB,EAAWE,SAAW,KAAM,CAC9B,SAGFZ,EAAeM,KAAKI,GAdtBV,EAAMA,KAAAA,SAAAA,EAANa,GAAMb,MAANa,GAAAC,SAAAC,EAAAD,UAEAlB,MAAAI,eAAAA,kCAOET","file":"../../../../../felixhayashi/tiddlymap/js/edgeTypeSubscriber/EdgeTypeSubscriberRegistry.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeTypeSubscriberRegistry\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**\n * Registry to store and retrieve EdgeTypeSubcriber modules that are responsible\n * for handling the retrieval, insertion and deletion of EdgeType objects.\n */\nclass EdgeTypeSubscriberRegistry {\n\n  /**\n   * @param {AbstractEdgeTypeSubscriber[]} subscribers\n   * @param {EdgeType[]} allEdgeTypes\n   * @param {Tracker} tracker\n   */\n  constructor(subscribers, allEdgeTypes, tracker) {\n\n    this.subscriberClasses = subscribers;\n    this.tracker = tracker;\n\n    this.updateIndex(allEdgeTypes);\n\n  }\n\n  /**\n   * Gets all matching subscribers for a type.\n   *\n   * @param {EdgeType} edgeType\n   * @returns AbstractEdgeTypeSubscriber[]\n   */\n  getAllForType(edgeType) {\n\n    const allSubscribers = this.allSubscribers;\n    const subscribersForType = [];\n\n    for (let i = 0, l = allSubscribers.length; i < l; i++) {\n\n      if (allSubscribers[i].canHandle(edgeType)) {\n\n        subscribersForType.push(allSubscribers[i]);\n\n        if (allSubscribers[i].skipOthers) {\n          break;\n        }\n      }\n    }\n\n    return subscribersForType;\n\n  }\n\n  /**\n   * Gets all subscribers.\n   *\n   * @returns AbstractEdgeTypeSubscriber[]\n   */\n  getAll() {\n\n    return this.allSubscribers;\n\n  }\n\n  /**\n   * Indexes all subscribers. Moreover, subscribers get linked to the edge\n   * types that currently exist in the wiki.\n   *\n   * This method should be called everytime after an edge type is added or\n   * removed in the system.\n   *\n   * @param {EdgeType[]} allEdgeTypes\n   */\n  updateIndex(allEdgeTypes) {\n\n    const allSubscribers = [];\n\n    // instantiate and register all active subscriber modules\n    const subscriberClass = this.subscriberClasses;\n    for (let moduleName in subscriberClass) {\n\n      const subscriber = new (subscriberClass[moduleName])(allEdgeTypes);\n      subscriber.setTracker(this.tracker);\n\n      // ignore all subscribers that have their ignore flag set to false\n      if (subscriber.ignore === true) {\n        continue;\n      }\n\n      allSubscribers.push(subscriber);\n    }\n\n    // sort subscribers by priority\n    allSubscribers.sort((s1, s2) => s2.priority - s1.priority);\n\n    this.allSubscribers = allSubscribers;\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport default EdgeTypeSubscriberRegistry;\n"],"sourceRoot":"../../../../../../src/plugins"}