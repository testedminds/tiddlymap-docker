{"version":3,"sources":["felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/ListEdgeTypeSubscriber.js"],"names":["_utils","require","_AbstractMagicEdgeTypeSubscriber","ListEdgeTypeSubscriber","allEdgeTypes","options","arguments","length","undefined","_classCallCheck","this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","_extends","priority","edgeType","namespace","tObj","fieldName","toWL","$tw","utils","parseStringArray","fields","edge","type","to","name","list","slice","toTRef","tracker","getTiddlerById","push","_utils2","default","setField","stringifyList","index","indexOf","splice"],"mappings":"gjBAaA,IAAAA,QAAAC,QAAA,wFACA,IAAAC,kCAAAD,QAAA;;;;;;;;;;GAoBME,kDAKJ,SAAAA,GAAYC,GAA4B,GAAdC,GAAcC,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,KAAAG,iBAAAC,KAAAP,EAAA,OAAAQ,4BAAAD,MAAAP,EAAAS,WAAAC,OAAAC,eAAAX,IAAAY,KAAAL,KArB1CN,EAqB0CY,UArB1CC,SAAA,IAAAZ,uDA4BYa,GAER,MAAOA,GAASC,YAAc,2DAOTC,EAAMC,EAAWC,GAEtC,MAAOC,KAAIC,MAAMC,iBAAiBL,EAAKM,OAAOL,yCAOrCD,EAAMO,EAAMC,GAErB,IAAKD,EAAKE,GAAI,CA3BwB,OAgCtC,GAAMC,GAAOF,EAAKE,IAElB,IAAIC,GAAOR,IAAIC,MAAMC,iBAAiBL,EAAKM,OAAOI,GAIlDC,IAAQA,OAAYC,OA3BrB,IAAAC,GAAAvB,KAAAwB,QAAAC,eAAAR,EAAAE,GAEDE,GAAAK,KAAAH,EAiCEI,SAAAC,QAAMC,SAASnB,EAAMU,EAAMP,IAAIC,MAAMgB,cAAcT,GAEnD,OAAOJ,wCAOEP,EAAMO,EAAMC,GAErB,GAAIG,GAAOR,IAAIC,MAAMC,iBAAiBL,EAAKM,OAAOE,EAAKE,MAIvDC,IAAQA,OAAYC,OAhCnB,IAAAC,GAAAvB,KAAAwB,QAAAC,eAAAR,EAAAE,GAED,IAAAY,GAAAV,EAAAW,QAAAT,EACA,IAAAQ,GAAab,EAAAA,CAoCXG,EAAKY,OAAOF,EAAO,GA/BrBJ,QAAAC,QAAAC,SAAAnB,EAAAQ,EAAAE,KAAAP,IAAAC,MAAAgB,cAAAT,GAqCA,OAAOJ,oEA5BPxB,uBAAAA","file":"../../../../../../felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/ListEdgeTypeSubscriber.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/list\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport AbstractMagicEdgeTypeSubscriber from '$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber';\n\n/*** Code **********************************************************/\n\n/**\n * The ListEdgeTypeSubstriber deals with connections that are stored inside\n * tiddler fields in a tiddler-list format.\n *\n * If an EdgeType with a 'tw-list\" namespace is inserted or deleted, the type's name\n * is interpreted as field name and the list of connections is stored or removed in a tiddler\n * field with of that name. Each outgoing connection to a tiddler is stored by\n * inserting the title the edge is pointing to into a list.\n *\n * Say you the user creates a connection between tiddler \"Dawna Dozal\" and\n * tiddler \"Toney Thacker\" and names the connection \"tw-list:friends\". Then a field\n * named \"friends\" will be created in tiddler \"Dawna Dozal\" and \"Toney Thacker\" will be\n * added to this field.\n *\n * @see http://tiddlymap.org/#tw-list\n */\nclass ListEdgeTypeSubscriber extends AbstractMagicEdgeTypeSubscriber {\n\n  /**\n   * @inheritDoc\n   */\n  constructor(allEdgeTypes, options = {}) {\n    super(allEdgeTypes, { priority: 10, ...options });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  canHandle(edgeType) {\n\n    return edgeType.namespace === 'tw-list';\n\n  }\n\n  /**\n   * @override\n   */\n  getReferencesFromField(tObj, fieldName, toWL) {\n\n    return $tw.utils.parseStringArray(tObj.fields[fieldName]);\n\n  }\n\n  /**\n   * Stores and maybe overrides an edge in this tiddler\n   */\n  insertEdge(tObj, edge, type) {\n\n    if (!edge.to) {\n      return;\n    }\n\n    // get the name without the private marker or the namespace\n    const name = type.name;\n\n    let list = $tw.utils.parseStringArray(tObj.fields[name]);\n    // we need to clone the array since tiddlywiki might directly\n    // returned the auto-parsed field value (as in case of tags, or list)\n    // and this array would be read only!\n    list = (list || []).slice();\n\n    // transform\n    const toTRef = this.tracker.getTiddlerById(edge.to);\n\n    list.push(toTRef);\n\n    // save\n    utils.setField(tObj, name, $tw.utils.stringifyList(list));\n\n    return edge;\n\n  };\n\n  /**\n   * Deletes an edge in this tiddler\n   */\n  deleteEdge(tObj, edge, type) {\n\n    let list = $tw.utils.parseStringArray(tObj.fields[type.name]);\n    // we need to clone the array since tiddlywiki might directly\n    // returned the auto-parsed field value (as in case of tags, or list)\n    // and this array would be read only!\n    list = (list || []).slice();\n\n    // transform\n    const toTRef = this.tracker.getTiddlerById(edge.to);\n\n    const index = list.indexOf(toTRef);\n    if (index > -1) {\n      list.splice(index, 1);\n    }\n\n    // save\n    utils.setField(tObj, type.name, $tw.utils.stringifyList(list));\n\n    return edge;\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport { ListEdgeTypeSubscriber };\n"],"sourceRoot":"../../../../../../../src/plugins"}