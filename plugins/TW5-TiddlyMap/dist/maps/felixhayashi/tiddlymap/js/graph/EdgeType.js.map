{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/EdgeType.js"],"names":["_MapElementType2","require","_utils","_environment","env","EdgeType","id","data","_classCallCheck","this","_EdgeType$getIdParts","getIdParts","marker","namespace","name","getId","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","path","edgeTypes","fieldMeta","arrows","style","invertedArrow","isArrowEnabled","toArrow","biArrow","freeze","label","arguments","length","undefined","_utils2","default","match","edgeTypeRegex","getInstance","_extends","show-label","direction","arrow","_typeof","enabled","RegExp"],"mappings":"guBAaA,IAAAA,kBAAAC,QAAA,oHACA,IAAAC,QAAAD,QAAA,wFACA,IAAAE,cAAAF,QAAA,2DAAYG;;;;;;;;;;GAWNC,oCAMJ,SAAAA,GAAYC,EAAIC,GAAMC,gBAAAC,KAAAJ,EAAA,IAAAK,GAIgBL,EAASM,WAAWL,GAAhDM,EAJYF,EAIZE,OAAQC,EAJIH,EAIJG,UAAWC,EAJPJ,EAIOI,IAC3BR,GAAKD,EAASU,MAAMH,EAAQC,EAAWC,EALnB,IAAAE,GAAAC,2BAAAR,MAAAJ,EAAAa,WAAAC,OAAAC,eAAAf,IAAAgB,KAAAZ,KAQdH,EAAIF,IAAIkB,KAAKC,UAAWlB,EAASmB,UAAWjB,GAElDS,GAAKV,GAAKA,CA/BdU,GAAAJ,OAAAA,CAiCII,GAAKF,KAAOA,CA3BhBE,GAAAH,UAAAA,CAEA,IAAAY,IAAAT,EAAAU,WAAAD,MA8BI,IAAIA,EAAQ,CAEVT,EAAKW,cAAgBC,eAAeH,EAAQ,OAC5CT,GAAKa,QAAUD,eAAeH,EAAQ,OAASG,eAAeH,EAAQ,SA1BtEpB,GAAAA,QA4BgBW,EAAKW,gBAAkBX,EAAKa,OAE5C,IAAIb,EAAKc,QAAS,CA5BtBd,EAAAa,QAAA,IA8BMb,GAAKW,cAAgB,UA1B3B,CA+BIX,EAAKa,QAAU,KA/BGV,OAAAY,OAAAf,EAAA,OAAAA,sDA6EpB,MAAOP,MAAKuB,OAASvB,KAAKK,8CAjCD,GAATR,GAAS2B,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAJ,EAjCrB3B,GAAA8B,QAAAC,QAAKzB,iBAALN,EAAAF,IAAAkB,KAAAC,UAAA,IACA,IAAKT,GAAOA,EAAZwB,MAAAC,kBAqCA,QAlCA3B,OAAMa,EAAU,IAAKC,GAoCnBb,UAAYyB,EAAM,IAAMA,EAAM,IAAO,GAlCvCxB,KAAIW,EAAQ,IAAAa,EAAA,IAAA,sCAkDkC,GAAnC1B,GAAmCqB,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAA1B,EAA0B,IAAtBpB,GAAsBoB,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAV,EAAU,IAANnB,GAAMmB,UAAA,EAE9C,OAAOnB,GArEaF,GAAAC,GAAAA,EAAA,KAAAC,EAoCrB,sDAQ0BT,UAAAmC,YAAA,SAAAlC,GAAA,MAAAA,aAAAD,UAAAC,EAAA,GAAAD,UAAAC,GAgD7BD,UAASmB,UAATiB,YA9CInC,iBAAAA,QAAKkB,WACLQ,SAgDFU,iBASF,IAAMd,gBAAiB,QAAjBA,GAAkBH,EAAQkB,GA/C9B,GAAAC,GAAAnB,EAAAkB,EAmDA,IAAIC,GAAS,MAAQD,IAAc,KAAM,CAGvC,MAAO,MAGT,aAAcC,KAAP,YAAA,YAAAC,QAAOD,MAAU,SAAWA,EAAME,UAAY,MAAQF,IAAU,KAUzE,IAAML,eAAgB,GAAIQ,QAAO,8CAIlB1C","file":"../../../../../felixhayashi/tiddlymap/js/graph/EdgeType.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport MapElementType from '$:/plugins/felixhayashi/tiddlymap/js/MapElementType';\nimport utils          from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport * as env       from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\n\n/*** Code **********************************************************/\n\n/**\n * This class is used to abstract edge types. It facilitates the parsing\n * of style information, the translation of type names into actual type data\n * or the persistance of edge type data.\n *\n * Note: EdgeType instances are immutable (frozen).\n */\nclass EdgeType extends MapElementType {\n\n  /**\n   * @param {EdgeTypeId} id\n   * @param {Object} [data] @see http://visjs.org/docs/network/edges.html\n   */\n  constructor(id, data) {\n\n    // we do not simply use the provided id but disassemble and\n    // reassemble it again to ensure the id is well formatted.\n    const { marker, namespace, name } = EdgeType.getIdParts(id);\n    id = EdgeType.getId(marker, namespace, name);\n\n    // call the parent constructor\n    super(id, env.path.edgeTypes, EdgeType.fieldMeta, data);\n\n    this.id = id;\n    this.marker = marker;\n    this.name = name;\n    this.namespace = namespace;\n\n    const arrows = (this.style || {}).arrows;\n\n    if (arrows) {\n\n      this.invertedArrow = isArrowEnabled(arrows, 'from');\n      this.toArrow = isArrowEnabled(arrows, 'to') || isArrowEnabled(arrows, 'middle');\n      // determine if bi arrows (either from+to or no arrows)\n      this.biArrow = (this.invertedArrow === this.toArrow);\n\n      if (this.biArrow) {\n        this.toArrow = true;\n        this.invertedArrow = true;\n      }\n\n    } else {\n\n      this.toArrow = true;\n    }\n\n    Object.freeze(this);\n\n  }\n\n  /**\n   * Returns an object holding the parts that make up the edge type id.\n   *\n   * @param {EdgeTypeId} id\n   * @return {{marker: (*|string), namespace: (*|string), name: (*|string)}}\n   */\n  static getIdParts(id = '') {\n\n    id = utils.getWithoutPrefix(id, `${env.path.edgeTypes}/`);\n    const match = id.match(edgeTypeRegex) || [];\n\n    return {\n      marker: match[1] || '',\n      namespace: (match[3] && match[2]) || '',\n      name: (match[3] || match[2]) || ''\n    };\n\n  };\n\n  /**\n   * Creates an {@link EdgeTypeId} from a set of parts that make up the id.\n   * If it is not possible to create the id from the parts, the default\n   * edge type 'tmap:unknown' is returned.\n   *\n   * @param {string} marker\n   * @param {string} namespace\n   * @param {string} name\n   * @return {EdgeTypeId}\n   */\n  static getId(marker = '', namespace = '', name) {\n\n    return name\n      ? marker + (namespace && `${namespace}:`) + name\n      : 'tmap:unknown';\n\n  }\n\n  getLabel() {\n\n    return this.label || this.name;\n\n  }\n}\n\n/**\n  * @see https://github.com/babel/babel/issues/4854\n  * @param {string} id - Either the edge type id (name)\n  *     or a tiddler reference denoting the type or an\n  *     `EdgeType` object (that is directly bounced back). If the\n  *     id can be translated into a tiddler object that resides in\n  *     the edge type path, then its data is retrieved automatically.\n */\nEdgeType.getInstance = id => id instanceof EdgeType ? id : new EdgeType(id);\n\nEdgeType.fieldMeta = {\n  ...MapElementType.fieldMeta,\n  'label': {},\n  'show-label': {},\n};\n\n/**\n *\n * @param {Object} arrows\n * @param {('from'|'to'|'middle')} direction\n * @return {boolean}\n */\nconst isArrowEnabled = (arrows, direction) => {\n\n  const arrow = arrows[direction];\n\n  if (arrow == null && direction === 'to') {\n    // if the arrow is not further specified and its direction is to\n    // we regard it as enabled.\n    return true;\n  }\n\n  return typeof arrow === 'object' ? arrow.enabled !== false : arrow === true;\n\n};\n\n/**\n * An edge-type id consists of the following parts of which the\n * first two are optional: `[marker][namespace:]name`\n *\n * The colon is not considered to be part of the namespace.\n */\nconst edgeTypeRegex = new RegExp('^(_?)([^:_][^:]*):?([^:]*)');\n\n/*** Exports *******************************************************/\n\nexport default EdgeType;\n"],"sourceRoot":"../../../../../../src/plugins"}