{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/MapElementType.js"],"names":["_utils","require","MapElementType","id","root","fieldMeta","data","_classCallCheck","this","_fieldMeta","fullPath","isShipped","$tw","wiki","getSubTiddler","$tm","path","pluginRoot","_load","isFullPath","_utils2","default","startsWith","tRef","_loadFromTiddler","Tiddler","_typeof","field","tiddler","tObj","getTiddler","shadowTObj","rawData","utils","extend","fields","parser","parse","rawVal","style","isMerge","parseJSON","merge","silently","title","text","stringify","call","exists","Object","assign","getCreationFields","getModificationFields","addTiddler","description","JSON","modified","created"],"mappings":";;;;;;;;;;AAaA,GAAAA,QAAAC,QAAA,kRAOMC,2BAEJ,QAAAA,GAAYC,EAAIC,EAAMC,EAAWC,GAAMC,gBAAAC,KAAAN,EAErCM,MAAKL,GAAKA,CACVK,MAAKJ,KAAOA,CACZI,MAAKC,WAAaJ,CAClBG,MAAKE,SAAcF,KAAKJ,KAAxB,IAAgCI,KAAKL,EACrCK,MAAKG,UAAYC,IAAIC,KAAKC,cAAcC,IAAIC,KAAKC,WAAYT,KAAKE,SAXtEF,MAAAU,MAAAZ,GAAAE,KAAAE,wDAUIJ,GAgBA,IAAKA,EAAM,CAZX,OAIF,SAAAA,KAAA,SAAA,CAeI,GAAMa,GAAaC,QAAAC,QAAMC,WAAWhB,EAAME,KAAKJ,KAC/C,IAAMmB,GAAQJ,EAAab,EAAUE,KAAKJ,KAA5B,IAAoCE,CAClDE,MAAKgB,iBAAiBD,OAEjB,IAAIjB,YAAgBM,KAAIa,QAAS,CAEtCjB,KAAKgB,iBAAiBlB,OAEjB,WAAWA,KAAP,YAAA,YAAAoB,QAAOpB,MAAS,SAjBjB,CAEV,IAAKA,GAALqB,KAAWnB,MAAAC,WAAA,CAkBPD,KAAKmB,GAASrB,EAAKqB,gDAHZC,GAkBX,GAAMC,GAAOT,QAAAC,QAAMS,WAAWF,EAf1B,KAAAC,EAAKF,CAER,OAIH,GAAAI,GAAAnB,IAAAC,KAAAC,cAAAC,IAAAC,KAAAC,WAAAT,KAAAE,aAmBE,IAAMsB,GAAUpB,IAAIqB,MAAMC,UAAWH,EAAWI,OAAQN,EAAKM,OAE7D,KAAK,GAAIR,KAASnB,MAAKC,WAAY,CAEjC,GAAM2B,GAAS5B,KAAKC,WAAWkB,GAAOU,KACtC,IAAMC,GAASN,EAAQL,EAEvBnB,MAAKmB,GAAUS,EAASA,EAnBXR,KAAAA,KAASU,GAAAA,sCAcxB,MAAKlB,SAAAC,QAAIM,cAAclB,KAAAA,6CAuBhB8B,EAAOC,GAff,SAAAD,KAAA,SAAA,CAEDA,EAAAnB,QAAAC,QAAAoB,UAAAF,GAuBE,UAAWA,KAAP,YAAA,YAAAb,QAAOa,MAAU,SAAU,CAE7B,GAAIC,EAAS,CAEXpB,QAAAC,QAAMqB,MAAMlC,KAAK+B,MAAOA,OAEnB,CAlBV/B,KAAA+B,MAAAA,mCAsBIhB,EAAAoB,GAGJ,IAAApB,EAAA,CAEDA,EAAAf,KAAAE,aAmBS,UAAWa,KAAS,SAAU,CAEnC,OAMF,GAAMY,IACJS,MAAOrB,EACPsB,KAAM,GAGR,KAAKzB,QAAAC,QAAMC,WAAWC,EAAMf,KAAKJ,MAAO,CAItC+B,EAAOhC,GAAKK,KAAKL,GAblB,IAAA,GAAAwB,KAAAnB,MAAAC,WAAA,CAED,GAAAqC,GAAAtC,KAAAC,WAAAkB,GAAAmB,SAEAX,GAAMA,GAASW,EAAAA,EAAAC,KAAAvC,KAAAA,KAAAmB,IAAAnB,KAAAmB,GAAA,IAAfnB,KAAAwC,SAAA,CAsBEC,OAAOC,OAAOf,EAAQvB,IAAIC,KAAKsC,qBAf/B,GAAAR,IAAA,KAAA,CAEAR,OAAAA,OAAYA,EAAZvB,IAAAC,KAAAuC,yBAIFxC,IAAAC,KAAAwC,WAAA,GAAAzC,KAAAa,QAAAU,mBAYAjC,gBAAIyC,WACFW,eACAL,OACDZ,MAAAjB,QAAAC,QAAAoB,UAmBDK,UAAWS,KAAKT,WAfjBU,YAkBDC,4BAfFvD","file":"../../../../../felixhayashi/tiddlymap/js/graph/MapElementType.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/MapElementType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/*** Code **********************************************************/\n\n/**\n * @abstract\n */\nclass MapElementType {\n\n  constructor(id, root, fieldMeta, data) {\n\n    this.id = id;\n    this.root = root;\n    this._fieldMeta = fieldMeta;\n    this.fullPath = `${this.root}/${this.id}`;\n    this.isShipped = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath);\n\n    // finally get the data\n    this._load(data || this.fullPath);\n\n  }\n\n  /**\n   * Load the type's data. Depending on the constructor arguments,\n   * the data source can be a tiddler, a type store\n   *\n   * @private\n   */\n  _load(data) {\n\n    if (!data) {\n\n      return;\n    }\n\n    if (typeof data === 'string') { // assume id or full path\n\n      const isFullPath = utils.startsWith(data, this.root);\n      const tRef = (isFullPath ? data : `${this.root}/${data}`);\n      this._loadFromTiddler(tRef);\n\n    } else if (data instanceof $tw.Tiddler) {\n\n      this._loadFromTiddler(data);\n\n    } else if (typeof data === 'object') { // = type or a data object\n\n      for (let field in this._fieldMeta) {\n        this[field] = data[field];\n      }\n    }\n\n  }\n\n  /**\n   * Retrieve all data from the tiddler provided. If a shadow tiddler\n   * with the same id exists, its data is merged during the load\n   * process.\n   *\n   * @private\n   */\n  _loadFromTiddler(tiddler) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj) {\n\n      return;\n    }\n\n    const shadowTObj = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath) || {};\n\n    // copy object to allow manipulation of the data\n    const rawData = $tw.utils.extend({}, shadowTObj.fields, tObj.fields);\n    // allow parsers to transform the raw field data\n    for (let field in this._fieldMeta) {\n\n      const parser = this._fieldMeta[field].parse;\n      const rawVal = rawData[field];\n\n      this[field] = (parser ? parser.call(this, rawVal) : rawVal);\n    }\n\n  }\n\n  /**\n   * Method to determine whether or not this type exists. A type\n   * exists if a tiddler with the type's id can be found below\n   * the type's root path.\n   *\n   * @return {boolean} True if the type exists, false otherwise.\n   */\n  exists() {\n\n    return utils.tiddlerExists(this.fullPath);\n\n  }\n\n  setStyle(style, isMerge) {\n\n    // preprocessing: try to turn string into json\n    if (typeof style === 'string') {\n\n      style = utils.parseJSON(style);\n\n    }\n\n    // merge or override\n    if (typeof style === 'object') {\n\n      if (isMerge) {\n\n        utils.merge(this.style, style);\n\n      } else {\n\n        this.style = style;\n\n      }\n    }\n\n  }\n\n  /**\n   * Store the type object as tiddler in the wiki. If the `tRef`\n   * property is not provided, the default type path prefix\n   * will be used with the type id appended. Stringifiers provided in\n   * the field meta object (that was passed to the constructor) are\n   * called.\n   *\n   * @param {string} [tRef] - If `tRef` is provided, the type\n   *     data will be written into this tiddler and the id property\n   *     is added as extra field value. Only do this is only for\n   *     dumping purposes!\n   * @param {boolean} [silently=false] do not update the modification date\n   */\n  save(tRef, silently) {\n\n    if (!tRef) {\n\n      tRef = this.fullPath;\n\n    } else if (typeof tRef !== 'string') {\n\n      return;\n\n    }\n\n    // also add an empty text field to guard against\n    // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n    const fields = {\n      title: tRef,\n      text: ''\n    };\n\n    if (!utils.startsWith(tRef, this.root)) {\n\n      // = not the standard path for storing this type!\n      // in this case we add the id to the output.\n      fields.id = this.id;\n\n    }\n\n    // allow parsers to transform the raw field data\n    for (let field in this._fieldMeta) {\n\n      const stringify = this._fieldMeta[field].stringify;\n\n      fields[field] = (stringify ? stringify.call(this, this[field]) : this[field]);\n    }\n\n    if (!this.exists()) { // newly created\n      Object.assign(fields, $tw.wiki.getCreationFields());\n    }\n\n    if (silently !== true) {\n      // add modification date to the output;\n      Object.assign(fields, $tw.wiki.getModificationFields());\n    }\n\n    $tw.wiki.addTiddler(new $tw.Tiddler(fields));\n\n  }\n}\n\n/**\n * A list of fields that are used as data identifiers. Only these\n * listed keys are acknowledged by the load and save functions in\n * this class.\n *\n * This object resembles tw's field modules that are used by\n * `boot.js` to decide how fields are parsed and stringified again.\n */\nMapElementType.fieldMeta = {\n  'description': {},\n  'style': {\n    parse: utils.parseJSON,\n    stringify: JSON.stringify\n  },\n  'modified': {}, // translation handled by TW's core\n  'created': {} // translation handled by TW's core\n};\n\n/*** Exports *******************************************************/\n\nexport default MapElementType;\n"],"sourceRoot":"../../../../../../src/plugins"}