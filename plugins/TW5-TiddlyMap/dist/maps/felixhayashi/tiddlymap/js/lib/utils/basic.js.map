{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/basic.js"],"names":["_exception","require","ucFirst","string","toUpperCase","slice","hasElements","obj","Object","keys","length","escapeRegex","str","replace","path","separator","arguments","undefined","substring","lastIndexOf","startsWith","prefix","base64","window","Buffer","toString","btoa","bind","identity","_typeof","JSON","stringify","sort","map","key","isEqual","obj1","obj2","getRandomInt","min","max","Math","floor","random","needle","haystack","indexOf","hasSubString","sub","parseJSON","data","parse","right","left","arr","join","getWithoutNewLines","makeHashMap","initialValues","create","joinAndWrap","enumerable","configurable","writable","value","prototype","hasOwnProperty","el","className","parentNode","document","findAndRemoveClassNames","classNames","getAncestorWithClass","elements","getElementsByClassName","i","j","classList","remove","isInteger","Number","isFinite","replaceAll","defaultReplacement","subStrings","subString","replacement","Array","isArray","isTrue","confVal","defVal","n","parseInt","isNaN","index","splice","getPropertiesByPrefix","removePrefix","r","p","getWithoutPrefix","substr","pickRandom","getImgFromWeb","imgUri","callback","xhr","XMLHttpRequest","open","responseType","onerror","e","console","log","onload","this","readyState","status","response","size","blob","send","getFirstElementByClassName","cls","root","isRequired","text","EnvironmentError","getRandomLabel","options","adjective","noun","object","plural","_merge","dest","src","merge","_len","sources","_key","l","setDomListeners","task","target","listeners","isCapt","event","removeDOMChildNodes","childNodes","removeChild","remainder","divident","divisor","getNearestRasterPosition","_ref","raster","x","y","rasterHalf","distPrevX","distPrevY","mod","bindTo","context","fnNames","fn"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/basic.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport {\n  EnvironmentError\n} from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/**\n * Uppercase the first letter of a string.\n */\nexport const ucFirst = string => string && string[0].toUpperCase() + string.slice(1);\n\n/**\n * Function to find out whether an object has any enumerable properties\n * or, in case of an array, elements.\n *\n * @param {Object} obj\n * @return {boolean} True if at least one enumerable property exists,\n *     false otherwise.\n */\nexport const hasElements = obj => Object.keys(obj).length > 0;\n\n/**\n * When we do not know the string, we need to escape it.\n * @deprecated use tw's escapeRegExp instead\n */\nexport const escapeRegex = str => str.replace(/[-$^?.+*[\\]\\\\(){}|]/g, '\\\\$&');\n\n/**\n * Returns the basename of a path.\n * A path is a string with slashes (or another separator).\n *\n * @param {string} path - The path\n * @param {string} [separator='/']\n * @return {string} The basename\n */\nexport const getBasename = (path, separator = '/') => path.substring(path.lastIndexOf(separator) + 1);\n\n/**\n * Helper to increase the code semantics.\n *\n * @param {string} str - The string to work with.\n * @param {string} prefix - The sequence to test.\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\n */\nexport const startsWith = (str, prefix) => str.substring(0, prefix.length) === prefix;\n\n/**\n * Converts a string to base64 encoding.\n *\n * To do so, we either choose the native btoa browser function or the Buffer class\n * received via scope.\n *\n * @param {string} str\n */\nexport const base64 = typeof window === 'undefined'\n  ? (str => (new Buffer(str)).toString('base64'))\n  : window.btoa.bind(window);\n\n/**\n * If two objects have the same properties, with the same values\n * then identity identity(obj) === identity(obj2) will return true.\n *\n * @param obj\n * @return string\n */\nexport const identity = obj =>\n  (typeof obj === 'object' && obj !== null\n    ?  JSON.stringify(Object.keys(obj).sort().map(key => [ key, obj[key] ]))\n    : null);\n\n/**\n * Returns true if both objects have the same properties\n * @param obj1\n * @param obj2\n */\nexport const isEqual = (obj1, obj2) => identity(obj1) === identity(obj2);\n\n/**\n *\n * @param min\n * @param max\n */\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min) + min);\n\n/**\n * Checks if a value exists in an array. A strict search is used\n * which means that also the type of the needle in the haystack\n * is checked.\n *\n * @param {*} needle - The searched value.\n * @param {Array} haystack - The array.\n * @return Returns true if needle is found in the array, false otherwise.\n */\nexport const inArray = (needle, haystack) => haystack.indexOf(needle) !== -1;\n\n/**\n * Checks if a string exists in a string.\n */\nexport const hasSubString = (str, sub) => str.indexOf(sub) !== -1;\n\n/**\n * Try to turn the string into a javascript object. If the\n * transformation fails, return the optionally provided `data` object.\n *\n * @param {string} str - The string to parse.\n * @param {*} data - The default value if the operation fails.\n * @return {*} Either the object resulting from the parsing operation\n *     or `undefined` or `data` if the operation failed.\n */\nexport const parseJSON = (str, data) => {\n\n  try {\n\n    return JSON.parse(str);\n\n  } catch (Error) {\n\n    return data;\n\n  }\n\n};\n\n/**\n * Joins all elements of an array into a string where all elements\n * are wrapped between `left` and `right`.\n *\n * @param {Array} arr - The array to perform the join on.\n * @param {string} left - The wrapping string for the left side.\n * @param {string} right - The wrapping string for the right side.\n * @param {string} [separator] - The separator between a wrapped element\n *     and the next one. Defaults to space.\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\n */\nexport const joinAndWrap = (arr, left, right, separator = ' ') =>\n  left + arr.join(right + separator + left) + right;\n\n/**\n * Remove any newline from a string\n */\nexport const getWithoutNewLines = str =>\n  (typeof str === 'string') ? str.replace(/[\\n\\r]/g, ' ') : str;\n\n\n/**\n * Factory function to return a prototypeless object that is used as\n * map. It only has the property hasOwnProperty in order to to be\n * exchangeble with other framworks that depend on this method like\n * e.g. visjs.\n *\n * @param {Object} [initialValues] - an object whose own properties will be\n *     used to initialize the map.\n */\nexport const makeHashMap = initialValues => {\n\n  const map = Object.create(null);\n  Object.defineProperty(map, 'hasOwnProperty', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.prototype.hasOwnProperty.bind(map)\n  });\n\n  if (initialValues) {\n    for (let key in initialValues) {\n      if (initialValues.hasOwnProperty(key)) {\n        map[key] = initialValues[key];\n      }\n    }\n  }\n\n  return map;\n\n};\n\n/**\n * If an ancestor that possesses a specified class exists the the\n * element will be returned, otherwise undefined is returned.\n *\n * @param {Element} el\n * @param {string} className\n */\nexport const getAncestorWithClass = (el, className) => {\n\n  if (typeof el !== 'object' || typeof className !== 'string') {\n    return;\n  }\n\n  while (el.parentNode && el.parentNode !== document) {\n    el = el.parentNode;\n    if (el.classList.contains(className)) {\n      return el;\n    }\n  }\n\n};\n\n/**\n * Searches the dom for elements that possess a certain class\n * and removes this class from each element.\n *\n * @param {Array<string>} classNames - The class names to remove.\n */\nexport const findAndRemoveClassNames = function(classNames) {\n\n  for (let i = classNames.length; i--;) {\n    const elements = document.getElementsByClassName(classNames[i]);\n    for (let j = elements.length; j--;) {\n      elements[j].classList.remove(classNames[i]);\n    }\n  }\n\n};\n\n/**\n * Polyfill until `isInteger` has become official. If the target\n * value is an integer, return true, otherwise return false.\n * If the value is NaN or infinite, return false.\n *\n * @param {*} value - The value to be tested for being an integer.\n * @return {boolean} True if the value is an integer, false otherwise.\n */\nexport const isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n         isFinite(value) &&\n         Math.floor(value) === value;\n};\n\n/**\n *\n * @param {string} str\n * @param defaultReplacement\n * @param subStrings\n * @return {*}\n */\nexport const replaceAll = (str, defaultReplacement = '', subStrings) => {\n\n  for (let i = subStrings.length; i--;) {\n\n    let subString = subStrings[i];\n    let replacement = defaultReplacement;\n\n    if (Array.isArray(subString)) {\n      replacement = subString[1];\n      subString = subString[0];\n    }\n\n    str = str.replace(subString, replacement);\n  }\n\n  return str;\n\n};\n\n/**\n * Sadly, setting fields with tw means that we lose the type information\n * since field values are persisted as strings and the type is not\n * included.\n *\n * To ensure that flags are always interpreted correctly, the following\n * function exists.\n *\n * We regard the following values as `true` (order matters):\n *\n * # Any string that can be translated into a number unequal `0`\n * # `\"true\"`\n * # Any number unequal `0`\n * # Boolean `true`\n *\n * The following as false (order matters):\n *\n * # Any string that can be translated into number `0`\n * # Every string unequal `\"true\"`\n * # The number `0`\n * # Boolean `false`\n *\n */\nexport const isTrue = (confVal, defVal) => {\n\n  if (confVal == null) {\n    return !!defVal;\n  } else if (typeof confVal === 'string') {\n    var n = parseInt(confVal);\n    return (isNaN(n) ? (confVal === 'true') : (n !== 0));\n  } else if (typeof confVal === 'boolean') {\n    return confVal;\n  } else if (typeof confVal === 'number') {\n    return (n !== 0);\n  }\n\n  return false;\n\n};\n\n/**\n * If the array contains the element, the element is removed from\n * the array in-place and the removed element.\n */\nexport const removeArrayElement = (arr, el) => {\n\n  const index = arr.indexOf(el);\n  if (index > -1) {\n    return arr.splice(index, 1)[0];\n  }\n\n};\n\n/**\n * Returns a new object that contains only properties that start with\n * a certain prefix. The prefix is optionally removed from the result.\n *\n * @param {Object} obj\n * @param {string} prefix - The start sequence\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\n *     from the resulting property name, false otherwise.\n * @result {object}\n */\nexport const getPropertiesByPrefix = (obj, prefix, removePrefix) => {\n\n  const r = makeHashMap();\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      r[(removePrefix ? p.substr(prefix.length) : p)] = obj[p];\n    }\n  }\n\n  return r;\n\n};\n\n/**\n * Function to remove the prefix of a string\n */\nexport const getWithoutPrefix =\n  (str, prefix) => startsWith(str, prefix) ? str.substr(prefix.length) : str;\n\n\n/**\n *\n */\nexport const hasKeyWithPrefix = (obj, prefix) => {\n\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n\n};\n\n/**\n *\n * @param arr\n */\nexport const pickRandom = arr => arr[getRandomInt(0, arr.length-1)];\n\n/**\n * Loads the image from web and passes it to the callback as\n * object url.\n */\nexport const getImgFromWeb = (imgUri, callback) => {\n\n  if (!imgUri || typeof callback !== 'function') return;\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', imgUri, true);\n  xhr.responseType = 'blob';\n  xhr.onerror = function(e) { console.log(e); };\n  xhr.onload = function(e) {\n    if (this.readyState === 4 && (this.status===200 || (this.status === 0 && this.response.size > 0))) {\n      const blob = this.response;\n      callback(window.URL.createObjectURL(blob));\n    }\n  };\n\n  try { xhr.send();  } catch (e) { console.log(e); }\n\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n  //~ propPath = propPath.split(\".\");\n  //~ for (var i = propPath.length; i--;) {\n    //~ if (obj !== null && typeof obj === \"object\") {\n      //~ obj = obj[propPath[i]];\n  //~ }\n  //~\n//~ };\n\n/**\n * Works like get `getElementById()` but is based on a class name.\n * It will return the first element inside an optional parent (root)\n * that has a class of this name.\n *\n * @param {string} cls - The class name to search for.\n * @param {Element} [root=document] - The context to search in.\n * @param {boolean} [isRequired=true] - If true, an exception will be\n *     thrown if no element can be retrieved. This is important\n *     when depending on third party modules and class names change!\n * @throws {EnvironmentError} - May be thrown if\n *    `isRequired` is set to true.\n * @return {Element} Either a dom element or null is returned.\n */\nexport const getFirstElementByClassName = (cls, root, isRequired) => {\n\n  const el = (root || document).getElementsByClassName(cls)[0];\n  if (!el && (typeof isRequired === 'boolean' ? isRequired : true)) {\n    const text = `Missing element with class \"${cls}\" inside ${root}`;\n    throw new EnvironmentError(text);\n  }\n\n  return el;\n\n};\n\nexport const getRandomLabel = (options = {}) => {\n\n  const adjective = pickRandom([\n    'exciting', 'notable', 'epic', 'new', 'fancy',\n    'great', 'cool', 'fresh', 'funky', 'clever'\n  ]);\n\n  const noun = (options.object || pickRandom([\n    'concept', 'idea', 'thought', 'topic', 'subject'\n  ])) + (options.plural ? 's' : '');\n\n  return `My ${adjective} ${noun}`;\n\n};\n\nconst _merge = (dest, src) => {\n\n  if (typeof dest !== 'object') {\n    dest = {};\n  }\n\n  for (let p in src) {\n    if (src.hasOwnProperty(p)) {\n      if (src[p] != null) { // skip null or undefined\n        dest[p] = (typeof src[p] === 'object'\n          ? _merge(dest[p], src[p])\n          : src[p]); // primitive type, stop recursion\n      }\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Merges `src` into `dest` which means that the merge transforms\n * the `dest` object itself. If src and dest both have the same\n * property path, src does only replace the primitive data type\n * at the end of the path.\n *\n * @todo Should null really be skipped or treated as value?\n *\n * @param {Object} dest - The destination object.\n * @param {...Object} sources - At least one object to merge into `dest`.\n * @return {Object} The original `dest` object.\n */\nexport const merge = (dest, ...sources) => {\n\n  // start the merging; i = 1 since first argument is the destination\n  for (let i = 0, l = sources.length; i < l; i++) {\n    const src = sources[i];\n    if (src != null && typeof src === 'object') {\n      dest = _merge(dest, src);\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Adds or removes listeners from the target in capture or\n * non-capture (bubbling) mode.\n *\n * @param {string} task - Either \"add\" or \"remove\". Make sure to\n *     always call add and remove with *excatly* the same listeners\n *     Note: if you use bind, you change the function object.\n * @param {Element} target - The element to attach or remove the\n *     listener to or from.\n * @param {Object<string, (Function|Array)>} listeners - The key is\n *     the event name and the value is either a handler function\n *     or an array where the first index is the handler function and\n *     the second is a boolean that specifies whether to use capture\n *     or not.\n * @param {boolean} [isCapt=false] - Whether to run the handler in\n *     bubbling or capturing phase.\n */\nexport const setDomListeners = (task, target, listeners, isCapt) => {\n\n  isCapt = (typeof isCapt === 'boolean' ? isCapt : false);\n  task = task + 'EventListener';\n\n  for (let event in listeners) {\n\n    const l = listeners[event];\n\n    if (typeof l === 'function') {\n\n      target[task](event, l, isCapt);\n    } else { // expect Array\n\n      target[task](event, l[0], (typeof l[1] === 'boolean' ? l[1] : isCapt));\n    }\n\n  }\n\n};\n\n/**\n * Removes all child nodes of a DOM element. This includes element\n * and non-element objects.\n */\nexport const removeDOMChildNodes = el => {\n\n  for (let i = el.childNodes.length; i--;) {\n    el.removeChild(el.childNodes[i]);\n  }\n\n};\n\n/**\n * Implementation of the algebraic modulus operation.\n *\n * In javascript '%' is really a remainder operator, not a modulus.\n * Algebraically speaking, a modulus operation always yields\n * positive results, while '%' in js can yield negative results.\n *\n * Note: divident mod divisor\n *\n * @param {number} divident\n * @param {number} divisor\n * @return {number}\n */\nexport const mod = (divident, divisor) => {\n\n  const remainder = divident % divisor;\n\n  return Math.floor(remainder >= 0 ? remainder : remainder + divisor);\n\n};\n\n/**\n * Maps a coordinate to the nearest raster coordinate.\n *\n * @param {number} x\n * @param {number} y\n * @param {number} raster\n * @return {{x: number, y: number}}\n */\nexport const getNearestRasterPosition = ({ x, y }, raster) => {\n\n  const rasterHalf = raster / 2;\n\n  // calculate distances to previous raster lines\n  const distPrevX = mod(x, raster);\n  const distPrevY = mod(y, raster);\n\n  return {\n    x: distPrevX < rasterHalf ? x - distPrevX : x - distPrevX + raster,\n    y: distPrevY < rasterHalf ? y - distPrevY : y - distPrevY + raster\n  };\n\n};\n\n/**\n * Force early binding of functions to this context.\n *\n * @param context the context to bind this function to (typically `this`)\n * @param {Array<string>} fnNames - The prototype function names\n *     to bind to this context.\n */\nexport const bindTo = (context, fnNames) => {\n\n  for (let i = fnNames.length; i--;) {\n    const fn = context[fnNames[i]];\n    context[fnNames[i]] = fn.bind(context);\n  }\n\n};\n"],"sourceRoot":"../../../../../../../src/plugins"}