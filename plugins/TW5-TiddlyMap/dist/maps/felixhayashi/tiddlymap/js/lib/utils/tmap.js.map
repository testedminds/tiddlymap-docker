{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/tmap.js"],"names":["_vis","require","_exception","_basic","basicUtils","_wiki","wikiUtils","getLabel","tiddler","aliasField","tObj","getTiddler","fields","title","getIterableCollection","col","_vis2","default","DataSet","get","getValues","Array","isArray","result","keys","Object","i","length","push","convert","outputType","_typeof","InvalidArgumentException","mapper","array","hashmap","returnType","dataset","getDataUri","type","isForceBase64","imgTObj","body","text","encoding","$tw","config","contentTypeInfo","replace","hasSubString","getEdgeTypeMatches","filter","arguments","undefined","titles","base64","$tm","path","edgeTypes","iterator","removePrefix","eTyFiltAutoPrefix","getMatches","isEdgeTypeMatch","groupByProperty","prop","makeHashMap","item","val","getPrettyFilter","expr","operands","match","re","trim","stringsPlusDummies","split","operandIndex","parts","l","ctx","scaleFactor","viewCenter","rasterSize","color","_basicUtils$getNeares","centerX","scaledWidth","canvas","width","scaledHeight","height","extraLines","hSpace","Math","ceil","vSpace","left","right","top","centerY","drawRaster","beginPath","x","lineTo","bottom","y","fillStyle","stroke","refreshDataSet","ds","ltNew","ltOld","updated","withoutPosition","strokeStyle","id","isEqual","remove","removed","add","inserted","getDublicates","getId","tiddlers","getTiddlersWithField","limit","getTiddlerRef","index","key","keysOfItemsWithProperty","getLookupTable","lookupKey","keyOfItemWithProperty","lookupTable","idx","getSnapshotTitle","viewLabel","Date","toDateString"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/tmap.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport vis                  from '$:/plugins/felixhayashi/vis/vis.js';\nimport {\n  EnvironmentError,\n  InvalidArgumentException,\n}                           from '$:/plugins/felixhayashi/tiddlymap/js/exception';\nimport * as basicUtils      from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic';\nimport * as wikiUtils       from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki';\n\n/**\n * @param {Tiddler} tiddler\n * @param {string} aliasField - A tiddler field that contains an\n *     alternative title (e.g. \"caption\").\n * @return {string|undefined} If the `aliasField` exists and is not\n *     empty, the value of the `aliasField` otherwise the tiddler's\n *     title or undefined if the tiddler doesn't exist.\n */\nexport const getLabel = (tiddler, aliasField) => {\n  const tObj = wikiUtils.getTiddler(tiddler);\n  return (tObj && tObj.fields[aliasField]? tObj.fields[aliasField] : tObj.fields.title);\n};\n\n/**\n * This function will return a collection object whose data can be\n * via `Object.keys(col)` in a loop.\n *\n * @param {Collection} col - A collection\n * @return {Hashmap} The iterable object.\n */\nexport const getIterableCollection = col => col instanceof vis.DataSet ? col.get() : col;\n\n/**\n * Extract all the values from a collection. If `col` is an object,\n * only properties are considered that are its own and iterable.\n *\n * @param {Collection} col\n * @return {Array} An array\n */\nexport const getValues = col => {\n\n  if (Array.isArray(col)) {\n\n    return col; // bounce back.\n\n  } else if (col instanceof vis.DataSet) { // a dataset\n\n    return col.get({ returnType: 'Array' });\n\n  }\n\n  const result = [];\n  const keys = Object.keys(col);\n  for (let i = keys.length; i--;) {\n    result.push(col[keys[i]]);\n  }\n\n  return result;\n\n};\n\n/**\n * Transforms a collection of a certain type into a collection of\n * another type.\n *\n * **Attention**: When trying to convert an array into a object, the\n * array will be simply bounced back. Let's hope no one added enumerable\n * properties to Array.prototype :)\n *\n * @param {Collection} col - The collection to convert.\n * @param {CollectionTypeString} [outputType=\"dataset\"] - The output type.\n * @return {Collection} A **new** collection of type `outputType`.\n */\nexport const convert = (col, outputType) => {\n\n  if (typeof col !== 'object') {\n    throw new InvalidArgumentException(col, outputType);\n  }\n\n  if (outputType === 'object') {\n    outputType = 'hashmap';\n  }\n\n  const mapper = {\n    array: col => getValues(col),\n    hashmap: col =>\n      col instanceof vis.DataSet ? col.get({ returnType: 'Object' }) : col,\n    dataset: col =>\n      col instanceof vis.DataSet ? col : (!Array.isArray(col) ? getValues(col) : new vis.DataSet(col))\n  };\n\n  return mapper[outputType](col);\n\n};\n\n/**\n * @param {Tiddler} tiddler\n * @param {string} [type]\n * @param {boolean} [isForceBase64]\n * @return {string}\n */\nexport const getDataUri = (tiddler, type, isForceBase64) => {\n\n  const imgTObj = wikiUtils.getTiddler(tiddler);\n  type = type || imgTObj.fields.type || 'image/svg+xml';\n  let body = imgTObj.fields.text;\n  let encoding = $tw.config.contentTypeInfo[type].encoding;\n\n  if (type === 'image/svg+xml') {\n\n    // see http://stackoverflow.com/questions/10768451/inline-svg-in-css\n    body = body.replace(/\\r?\\n|\\r/g, ' ');\n\n    if (!basicUtils.hasSubString('xmlns', body)) {\n      // @tiddlywiki it is bad to remove the xmlns attribute!\n\n      body = body.replace(/<svg/, '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n    }\n\n  }\n\n  if (isForceBase64 && encoding !== 'base64') {\n    encoding = 'base64';\n    body = basicUtils.base64(body);\n  }\n\n  return `data:${type};${encoding},${body}`;\n\n};\n\n// @todo move this to environment\nconst eTyFiltAutoPrefix = '[all[]] ';\n\n/**\n *\n * @param filter\n * @param titles\n * @return {*}\n */\nexport const getEdgeTypeMatches = (filter = '', titles) => {\n\n  if (!titles) {\n    titles = wikiUtils.getTiddlersByPrefix(`${$tm.path.edgeTypes}/`, {\n      iterator: 'eachTiddlerPlusShadows',\n      removePrefix: true\n    });\n  }\n\n  if (titles != null && !Array.isArray(titles)) {\n    titles = Object.keys(titles);\n  }\n\n  return wikiUtils.getMatches(eTyFiltAutoPrefix + filter, titles);\n\n};\n\nexport const isEdgeTypeMatch = (title, filter = '') =>\n  wikiUtils.isMatch(title, eTyFiltAutoPrefix + filter);\n\n/**\n *\n */\nexport const groupByProperty = (col, prop) => {\n\n  col = getIterableCollection(col);\n\n  const result = basicUtils.makeHashMap();\n  const keys = Object.keys(col);\n\n  for (let i in keys) {\n\n    const item = col[keys[i]];\n    const val = item[prop];\n\n    if (val == null) { // null or undefined\n\n      // @todo use exception class\n      throw 'Cannot group by property ' + prop;\n\n    } else {\n\n      if (!Array.isArray(result[val])) {\n        result[val] = [];\n      }\n      result[val].push(item);\n\n    }\n  }\n\n  return result;\n\n};\n\n/**\n * Turns the filter expression in a nicely formatted (but unusable)\n * text, making it easier to edit long filter expressions.\n *\n * @param {string} expr - A valid filter expression.\n * @result {string} A formatted (unusable) filter expression.\n */\nexport const getPrettyFilter = expr => {\n\n  // remove outer spaces and separate operands\n  expr = expr.trim().replace('][', '] [');\n\n  // regex to identify operands\n  const re = /[+-]?\\[.+?[\\]\\}\\>]\\]/g;\n\n  // get operands\n  const operands = expr.match(re);\n\n  // replace operands with dummies and trim again to avoid trailing spaces\n  expr = expr.replace(re, ' [] ').trim();\n\n  // turn it into an array\n  const stringsPlusDummies = expr.split(/\\s+/);\n\n  let operandIndex = 0;\n  const parts = [];\n  for (let i = 0, l = stringsPlusDummies.length; i < l; i++) {\n    parts[i] = (stringsPlusDummies[i] === '[]' ? operands[operandIndex++] : stringsPlusDummies[i]);\n  }\n\n  return parts.join('\\n');\n\n};\n\n/**\n * This function will draw a raster on the network canvas that will\n * adjust to the network's current scaling factor and viewport offset.\n *\n * @param {CanvasRenderingContext2D} ctx - The canvas's context passed by vis.\n * @param {number} scaleFactor - The current scale factor of the network.\n * @param {Object} viewCenter - Virtual center point of the view.\n * @param {number} rasterSize - The size of the squares that are drawn.\n * @param {string} color - A string parsed as CSS color value.\n */\nexport const drawRaster = (ctx, scaleFactor, viewCenter, rasterSize, color = '#D9D9D9') => {\n\n  // from now on the most central raster point\n  const { x: centerX, y: centerY } = basicUtils.getNearestRasterPosition(viewCenter, rasterSize);\n\n  const scaledWidth = ctx.canvas.width / scaleFactor;\n  const scaledHeight = ctx.canvas.height / scaleFactor;\n\n  // some extra lines to ensure the canvas is completely filled with lines\n  const extraLines = rasterSize * 2;\n\n  // calculate the space that is required to draw the rasters\n  const hSpace = Math.ceil((scaledWidth / rasterSize) / 2) * rasterSize + extraLines;\n  const vSpace = Math.ceil((scaledHeight / rasterSize) / 2) * rasterSize + extraLines;\n\n  // align the space to the center points and calculate the offsets\n  const left = centerX - hSpace;\n  const right = centerX + hSpace;\n  const top = centerY - vSpace ;\n  const bottom = centerY + vSpace;\n\n  ctx.beginPath();\n\n  // draw vertical lines\n  for (let x = left; x < right; x += rasterSize) {\n    ctx.moveTo(x, top);\n    ctx.lineTo(x, bottom);\n  }\n\n  // draw horizontal lines\n  for (let y = top; y <= bottom; y += rasterSize) {\n    ctx.moveTo(left, y);\n    ctx.lineTo(right, y);\n  }\n\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  ctx.stroke();\n\n};\n\n/**\n * Updates a dataset.\n *\n * Note: never use the dataset's update() method, it does not properly remove\n * obsolete properties! – use remove and add instead.\n *\n * @param {vis.DataSet} [ds] - The dataset to be updated\n * @param {Hashmap<id, Node>} ltNew - Lookup table that contains the *new* set of nodes.\n */\nexport const refreshDataSet = (ds, ltNew) => {\n\n  const ltOld = ds.get({ returnType: 'Object' });\n\n  const inserted = [];\n  const updated = [];\n  const withoutPosition = [];\n  const removed = [];\n\n  for (let id in ltNew) {\n\n    if (ltOld[id]) { // element already exists in graph\n\n      if (basicUtils.isEqual(ltOld[id], ltNew[id])) {\n        // simply keep element\n        continue;\n      }\n\n      updated.push(id);\n      ds.remove(id);\n\n    } else {\n\n      inserted.push(id);\n\n    }\n\n    if (ltNew[id].x === undefined) {\n      withoutPosition.push(id);\n    }\n\n    ds.add(ltNew[id]);\n  }\n\n  for (let id in ltOld) {\n    if (!ltNew[id]) {\n      removed.push(id);\n      ds.remove(id);\n    }\n  }\n\n  return {\n    withoutPosition,\n    inserted,\n    updated,\n    removed,\n  };\n\n};\n\n/**\n * Returns the tmap id that is stored in a designated field in the tiddler.\n *\n * @param tiddler\n * @return {string} the tmap id of this tiddler\n */\nexport const getId = tiddler => wikiUtils.getTiddler(tiddler).fields['tmap.id'];\n\n/**\n * Returns all other tiddlers that have the same tmap.id field entry.\n *\n * Note: typically tiddlers don't have the same id assigned, however,\n * this can happen when tiddlers are imported or cloned.\n *\n * @param {Tiddler} tiddler\n * @return {array<TiddlerReference>} a list of tiddlers with the same id as the\n *    provided tiddler (excluding the provided tiddler itself).\n */\nexport const getDublicates = tiddler => {\n\n  const id = getId(tiddler);\n\n  if (!id) {\n\n    return [];\n\n  }\n\n  const tiddlers = wikiUtils.getTiddlersWithField('tmap.id', id, {limit: 2});\n  delete tiddlers[wikiUtils.getTiddlerRef(tiddler)];\n\n  return Object.keys(tiddlers);\n\n};\n\n/**\n * Function that searches an array for an object with a property\n * having a certain value.\n *\n * Attention: Not the item itself but the item's key is returned.\n *\n * @param {Collection} col - The collection to search in.\n * @param {string} key - The property name to look for.\n * @param {*} [val] - An optional value that the object's property must have\n *     in order to match.\n * @param {number} [limit] - An optional result limit (>0) to stop the search.\n * @return {Array<Id>} An array containing the indeces of matching items.\n */\nexport const keysOfItemsWithProperty = (col, key, val, limit) => {\n\n  col = getIterableCollection(col);\n\n  const keys = Object.keys(col);\n  const result = [];\n\n  limit = (typeof limit === 'number' ? limit : keys.length);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const index = keys[i];\n    if (typeof col[index] === 'object' && col[index][key]) {\n      if (!val || col[index][key] === val) {\n        result.push(index);\n        if (result.length === limit) {\n          break;\n        }\n      }\n    }\n  }\n\n  return result;\n\n};\n\n/**\n *\n * @param col\n * @param key\n * @param val\n * @return {*}\n */\nexport const keyOfItemWithProperty = (col, key, val) =>\n  keysOfItemsWithProperty(col, key, val, 1)[0];\n\n/**\n * In a collection where all elements have a **distinct** property\n * `lookupKey`, use the value of each element's `lookupKey` as key\n * to identify the object. If no property `lookupKey` is specified,\n * the collection's values are used as keys and `true` is used as value,\n * however, if the used keys are not strings, an error is thrown.\n *\n * @param {Collection} col - The collection for which to create a lookup table.\n * @param {string} [lookupKey] - The property name to use as index in\n *     the lookup table. If not specified, the collection values are tried\n *     to be used as indeces.\n * @return {Hashmap} The lookup table.\n */\nexport const getLookupTable = (col, lookupKey) => {\n\n  col = getIterableCollection(col);\n\n  const lookupTable = basicUtils.makeHashMap();\n  const keys = Object.keys(col);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n\n    const key = keys[i];\n    const idx = (lookupKey ? col[key][lookupKey] : col[key]);\n    const type = typeof idx;\n\n    if ((type === 'string' && idx !== '') || type === 'number') {\n      if (!lookupTable[idx]) { // doesn't exist yet!\n        lookupTable[idx] = (lookupKey ? col[key] : true);\n        continue;\n      }\n    }\n\n    // @todo use exception class\n    throw new Error(`Cannot use \"${idx}\" as lookup table index`);\n\n  }\n\n  return lookupTable;\n\n};\n\n/**\n * Alias for {@link getLookupTable}\n */\nexport const getArrayValuesAsHashmapKeys = getLookupTable;\n\n/**\n *\n * @param viewLabel\n * @param type\n */\nexport const getSnapshotTitle = (viewLabel, type) =>\n  `Snapshot – ${viewLabel} (${new Date().toDateString()}). ${type || 'png'}`;\n"],"sourceRoot":"../../../../../../../src/plugins"}