{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/wiki.js"],"names":["_exception","require","_basic","basicUtils","getTiddlerRef","tiddler","$tw","Tiddler","fields","title","InvalidArgumentException","getTiddler","wiki","arguments","length","undefined","tObj","defValue","field","tRef","Boolean","tiddlerExists","isShadowTiddler","setSidebarTab","setText","getTiddlersByPrefix","setField","value","text","addTiddler","deleteTiddlers","tiddlers","keys","Object","storyList","getTiddlerList","i","index","indexOf","splice","deleteTiddler","oldName","newName","isRemoveOldField","isIncludeSystemTiddlers","moveFieldValues","allTiddlers","getMatches","source","filter","compileFilter","_typeof","Array","isArray","callback","call","isMatch","type","getTranscludeNode","isBlock","children","getTiddlerNode","attributes","getElementNode","tag","class","className","registerTransclude","widget","name","removeArrayElement","makeChildWidget","notify","notifyTiddlerRef","message","notifier","display","isPreviewed","getVariable","cls","getAncestorWithClass","parentDomNode","parseFieldData","data","parseJSON","writeFieldData","indent","parseInt","JSON","stringify","clone","src","dest","setEntry","prop","getTiddlerData","isLeftVersionGreater","v1","v2","utils","checkVersions","getField","isDraft","isSystemOrDraft","isSystemTiddler","getMergedTiddlers","push","unshift","getCreationFields","Function","prototype","bind","apply","child","val","getChildWidgetByProperty","addTWlisteners","listeners","context","id","addEventListener","mv","oldPrefix","newPrefix","isForce","isDelete","targets","fromToMapper","makeHashMap","oldTRef","newTRef","replace","cp","prefix","deletedTiddlers","allTitles","startsWith","fieldName","options","isIncludeDrafts","hasOwnProp","result","limit","getTiddlerWithField","getTiddlersWithField","getWithoutPrefix","removePrefix","iterator","getModificationFields","touch","Date"],"mappings":"+iCAaA,IAAAA,YAAAC,QAAA,iDAIA,IAAAC,QAAAD,QAAA,2DAAYE;;;;;;;;;;AAQL,GAAMC,eAAAA,QAAAA,cAAgB,QAAhBA,GAAgBC,GAE3B,GAAIA,YAAmBC,KAAIC,QAAS,CAElC,MAAOF,GAAQG,OAAOC,UAEjB,UAAWJ,KAAY,SAAU,CAEtC,MAAOA,OAEF,CAEL,KAAM,IAAAL,YAAAU,yBAA6BL,IAehC,IAAMM,YAAAA,QAAAA,WAAa,QAAbA,GAAaN,GAAA,MACxBC,KAAIM,KAAKD,WAAWN,YAAmBC,KAAIC,QAAUF,EAAQG,OAAOC,MAAQJ,GADpD,IACpBO,UAAAA,QAAAA,SAAKD,QAALC,GAAKD,EAAWN,GAAA,GAAAA,GAAAQ,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAuBN,EAS3C,IAAMS,GAAOL,WAAWN,EAP1B,QAAAW,EAAAC,EAAAD,EAAAR,OAAAU,IAAAD,EAQE,IAASD,eAAAA,QAAAA,cAAkBA,QAAlBA,GAAkBA,GAY3B,IAAKX,EAAS,CARhB,MAAA,OAYE,GAAMc,GAAOf,cAAcC,EAE3B,OAAOe,SAAQD,IAASb,IAAIM,KAAKS,cAAcF,IAASb,IAAIM,KAAKU,gBAAgBH,KAL/E,IAAOI,eAAAA,QAAAA,cAAP,QAAOA,GAAPJ,GAWFK,QAAQC,oBAAoB,yBAAyB,GAAIN,GAiBpD,IAAMO,UAAAA,QAAAA,SAAW,QAAXA,GAAYrB,EAASa,EAAOS,GAEvC,IAAKtB,IAAYa,EAAO,CACtB,OAGF,GAAMC,GAAOf,cAAcC,EANtB,IAAMqB,GAAAA,iBAQTjB,MAAOU,GANTD,EAAKb,EAIL,IAAMc,GAAOf,IAAAA,KAAAA,WAAcC,EAA3B,KAEEI,IAAAA,IAAOU,QAAAA,IAAAA,EAAAA,OAAAA,KAAAA,CADHX,EAAAoB,KAAN,GAMAZ,EAAIA,GAAOV,KAAIM,QAAKD,EAAAA,EAOpBL,KAAIM,KAAKiB,WAAWb,EAJlBR,OAAAA,GAkBG,IAAMsB,gBAAAA,QAAAA,eAAiB,QAAjBA,GAAiBC,GAE5B,GAAMC,GAAOC,OAAOD,KAAKD,EACzB,IAAMG,GAAY5B,IAAIM,KAAKuB,eAAe,eAHrC,KAAML,GAAAA,GAAAA,EAAAA,OAAAA,KAAAA,CAMT,GAAIX,GAAOf,cAAc2B,EAASC,EAAKI,IAJzC,KAAMJ,IAAOC,KAAAA,cAAYF,EAAzBC,EAAAI,KAAA,CAGA,SAGI,GAAAC,GAAAH,EAAAI,QAAAnB,EACA,IAAAkB,KAAA,EAAA,CACAH,EAAAK,OAAAF,EAAA,EACDX,UAAA,eAAA,OAAAQ,GAKCR,IAAAA,KAAAA,cAASP,IAMXb,IAASkC,iBAAAA,QAAAA,gBAAT,QAASA,GAATC,EAAAC,EAAAC,EAAAC,EAAAb,GAtBG,GAAAU,IAAAC,EAAA,MA4BA,IAAMG,GAAAA,GAAAA,IAAAA,KAAAA,WAEX,KAAIJ,GAAAA,GAAAA,EAAqB3B,OAAAsB,KAAA,CAEzB,GAAMU,GAAAA,WAAcf,EAAYK,GAEhC,IAAKpB,EAAIoB,YAAgBtB,EAAAA,OAAzB2B,GAAuC,CAKnC,SADF,IAAIzB,GAAwBR,IAAOiC,KAAAA,gBAAUK,EAAAV,IAAA,CAC3C,SAGF,GAAKQ,GAAAA,mBACHF,EAAA1B,EAAAR,OAAAiC,GAGF,IAAMjC,EAAAA,CAKJA,EAAOiC,GAAW1B,UAAlBP,IAAAA,KAAOiC,WAAW1B,GAAAA,KAAAA,QAAlBC,EAAAR,KAsBOuC,IAAAA,YAAAA,QAAAA,WAAAA,QAAAA,GAAAA,EAAAA,GAGX,GAAIC,GAASjC,SAGb,IAAMH,GAAON,IAAIM,IAEjB,UAAWqC,KAAW,SAAU,CAC9BA,EAASrC,EAAKsC,cAAcD,GAI9B,GAAIlB,GAAY,aAAQA,KAAA,YAAA,YAAAoB,QAAApB,MAAA,SAAA,CAEtB,IAAKqB,MAAMC,QAAQtB,GAAW,CAC5BA,EAAWE,OAAOD,KAAKD,GAGzBiB,EAAS,QAAAA,GAAAM,GACP,IAAK,GAAIlB,GAAIL,EAASjB,OAAQsB,KAAM,CAClC,GAAMpB,GAAOJ,EAAKD,WAAWoB,EAAhBK,GACbkB,GAAStC,EAAMe,EAASK,MAtBzB,MAAAa,GAAAM,KAAA3C,EAAAoC,GAwCA,IAAAQ,SAAAA,QAAAA,QAAA,QAAAA,GAAAnD,EAAA4C,GAAA,MACL7C,eAAcC,KAAa0C,WAAWE,GAAU7C,cAAcC,KAAY,GAUxEoD,IAAMC,mBAAAA,QAAAA,kBADP,QACOA,GADPrD,EAAAsD,GAAA,OAGGtD,KAAAA,aACEoD,YACA9B,SACJiC,KAAU,SACVD,MAAWA,cAAAA,KARkBC,YAA1BD,UAAAA,GAeuB,IAC3BE,gBAAAA,QAAAA,eAAA,QAAAA,GAAAxD,GAAA,OAECyD,KAAAA,UACEzD,YACEoD,SACJG,KAAU,SAAAjC,MAAAvB,cAAAC,KANgBuD,aAejBG,IAAAA,gBAAAA,QAAAA,eAAAA,QAAAA,GAAAA,EAAAA,EAAiBnC,GAAjBmC,OAETN,KAAM,UACNO,IAAKP,EACLK,YACEG,OACER,KAAM,SACN9B,MAAOuC,IACXN,SAAUhC,IAAU6B,KAAM,OAAQ7B,KAAMA,QAUrC,IAAMuC,oBAAAA,QAAAA,mBAAqB,QAArBA,GAAsBC,EAAQC,EAAMhE,GAE/CF,WAAAmE,mBAAAF,EAAAR,SAAAQ,EAAAC,GAGAD,GAAOC,GAAQD,EAAOG,gBAAgBb,kBAAkBrD,EAAS,MAAjE+D,GAAOC,SAAQD,KAAAA,EAAOG,GAGtB,OAAOH,GAAOC,GAWHG,IAAAA,QAAAA,QAAAA,OAAAA,QAAAA,GAAAA,GAGX,GAAMC,GAAmB,0BAEzBnE,KAAIM,KAAKiB,WAAW,GAAIvB,KAAIC,SAC1BE,MAAQgE,EACR7C,KAAO8C,IAGTpE,KAAIqE,SAASC,QAAQH,GAQhB,IAAMI,aAAAA,QAAAA,YAAc,QAAdA,GAAcT,GAGvB,IAAAA,EAAO,CACR,MAAA,OAGC,GAAAA,EAAOU,YAAP,sBAAA,CADF,MAEO,UAAE,CACP,GAAMC,GAAM,4BACZ,SAAS5E,WAAW6E,qBAAqBZ,EAAOa,cAAeF,IAa3B7D,IAAyBgE,gBAAAA,QAAAA,eAAA,QAAAA,GAAA7E,GAAA,GAAAa,GAAAL,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAA,MAAA,IAAAsE,GAAAtE,UAAA,EAE/D,IAAMG,GAAOL,WAAWN,EAAxB,KAAMW,EAAOL,CAGX,MAAOwE,GACR,MAAAhF,YAAAiF,UAAApE,EAAAR,OAAAU,GAAAiE,GAcI,IAAME,gBAAAA,QAAAA,eAAiB,QAAjBA,GAAkBhF,EAASa,EAAOiE,EAAMG,GAEnD,UAAWH,KAAP,YAAA,YAAAhC,QAAOgC,MAAS,SAAU,CAA9B,OAIAG,EAASC,SAASD,EAAlBA,GAASC,EAASD,GAATpE,IAAT,OAAAoE,EAAA,CAGA5D,UAASrB,EAASa,EAAOsE,KAAKC,UAAUN,EAAM,KAAMG,IAQzCI,IAAAA,OAAAA,QAAAA,MAAAA,QAAAA,GAAAA,EAAAA,GAEXhE,SAASiE,EAAK,QAASC,GAOlB,IAAMC,UAAAA,QAAAA,SAAW,QAAXA,GAAYxF,EAASyF,EAAMnE,GAAjCrB,IAAAM,KAAAY,QAAApB,cAAAC,GAAA,KAAAyF,EAAAnE,GAWCwD,IAAO7E,UAAAA,QAAAA,SAASyF,QAATzF,GAASyF,EAAAA,EAAe3F,GAFhC,GAAA+E,GAAA7E,IAAAM,KAAAmF,eAAA3F,cAAAC,MAGL,OAAQ8E,GAAKW,IAAS,KAAO7E,EAAWkE,EAAKW,GAoBxC,IAAME,sBAAAA,QAAAA,qBAAuB,QAAvBA,GAAwBC,EAAIC,GAAL,MAAYD,KAAOC,GAAM5F,IAAI6F,MAAMC,cAAcH,EAAIC,GAOlE,IAAuBG,SAAAA,QAAAA,QAAShG,QAATgG,GAAShG,EAATY,GAASZ,MAAhCgG,UAAAhG,EAAA,OAAAY,GAOhB,IAAMO,SAAAA,QAAAA,QAAU,QAAVA,GAAWnB,EAASsB,GAE/BD,SAASrB,EAAS,OAAQsB,GASf2E,IAAAA,SAAAA,QAAAA,QAAAA,QAAAA,GAAAA,GAEX,GAAMtF,GAAOL,WAAWN,EACxB,OAAQW,IAAQA,EAAKsF,UAQhB,IAAAC,iBAAAA,QAAAA,gBAAA,QAAAA,GAAAlG,GAAA,MACLC,KAAIM,KAAK4F,gBAAgBpG,cAAcC,KAAaiG,QAAQjG,GAWvD,IAAMoG,mBAAAA,QAAAA,kBAAoB,QAApBA,GAAqB1E,EAAUtB,GAGxC,IAAA2C,MAAAC,QAAAtB,GAAA,CACD,OAICA,IAAAA,GAAAA,GAAAA,EAAcpB,OAAWoB,KAASK,CACnCL,EAAAK,GAAAzB,WAAAoB,EAAAK,IAGC,IAAAL,EAAAjB,OAAA,CACD,OAEDiB,EAAS2E,MAMTjG,MAAAA,GAAAsB,EAAA,GAAAvB,OAAAC,OACAsB,IAAAA,KAAS4E,wBAJPrG,IAAIM,KAAKgG,oBAUb7E,GAAA4E,QAAA,KAJE,OAAO,KAAKE,SAASC,UAAUC,KAAKC,MAAM1G,IAAIC,QAASwB,IAanD,IAAOkF,0BAAAA,QAAAA,yBAAP,QAAOA,GAAP7C,EAAA0B,EAAAoB,GAEAD,GAAAA,GAAQE,EAAAA,QACR,KAAA,GAAIF,GAAJrD,EAAW9C,OAAAsB,KAAA,CACT,GAAA6E,GAAOA,EAAP7E,EACD,IAAA6E,EAAAnB,KAAAoB,EAAA,CACF,MAAAD,OACF,CAbIA,EAAAE,EAAAF,EAAAnB,EAAAoB,EASD,IAAID,EAAO,CAQjB,MAAAA,MAeA,IAAAG,gBAAAA,QAAAA,eAAA,QAAAA,GAAAC,EAAAjD,EAAAkD,GANE,IAAK,GAAIC,KAAMF,GAAW,CACxBjD,EAAOoD,iBAAiBD,EAAIF,EAAUE,GAAIR,KAAKO,KAuB5C,IAAMG,IAAAA,QAAAA,GAAK,QAALA,GAAMC,EAAWC,EAAWC,EAASC,GAUhD,GAAMC,IAAUrG,IAAAA,IAAhBkG,EAAA,CACA,OALAC,QAAkBA,KAAY,UAAYA,EAAU,KASlDC,SAAgBC,KAAhB,UAAAD,EAAA,IAGE,IAAAC,GAAQrG,oBAAAiG,EACT,IAAAK,GAAA5H,WAAA6H,aAGF,KAAA,GAAA5F,GAAA0F,EAAAhH,OAAAsB,KAAA,CAED,GAAK6F,GAALH,EAAoBC,EARlB,IAAMG,GAAUD,EAAQE,QAAQT,EAAWC,EAU3CjG,IAAAA,IAAAA,KAASuG,cAATC,KAA2BH,EAAA,CAC3B,OAECA,EAAAE,GAAAC,EA7BE,IAAA,GAAAD,KAAAF,GAAA,CAoCPrG,SAAAuG,EAAA,QAAAF,EAAAE,GATI,IAAIJ,EAAU,CACZvH,IAAIM,KAAK4B,cAAcyF,IAI3B,MAAOF,GAmBF,IAAMK,IAAAA,QAAAA,GAAK,QAALA,GAAMV,EAAWC,EAAWC,GAAvB,MAUhBH,IAAAC,EAAaC,EAAAC,EAAA,OAOR,IAAIxF,gBAAAA,QAAAA,eAAT,QAASA,GAATiG,EAAoCtG,GAEhCzB,IAAAA,EAASkC,CACT8F,OANJvG,EAAWA,GAAYzB,IAAIM,KAAK2H,WAN3B,IAAAD,KASL,KAAK,GAAIlG,GAAIL,EAASjB,OAAQsB,KAAM,CAYtC,GAAAjC,WAAAqI,WAAAzG,EAAAK,GAAAiG,GAAA,CAVM/H,IAAIM,KAAK4B,cAAcT,EAASK,GAChCkG,GAAgB5B,KAAK4B,EAAgBlG,KAIzC,MAAOkG,GA8BF,IAAIlG,sBAAAA,QAAAA,qBAAuB,QAAvBA,GAAuBqG,EAAA9G,GAAA,GAAA+G,GAAA7H,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,KAE9B,IAAMG,GAAOL,EAAWoB,UAASC,IAApBpB,KAAb2H,WACA,IAAM/H,GAAcA,EAApBmI,kBAAA,IACA,IAAIC,GAAAA,WAAmBH,aACrB,IAAAzG,GAAKL,OAASnB,KAAOiI,EACnBI,IAAAA,GAAOrI,IAAOC,MAASO,GACvB,IAAA8H,GAAMA,EAAFA,OAAe,CAElB,KAAA,GAAA1G,GAAAJ,EAAAlB,OAAAsB,KAAA,CAEJ,GAAApB,GAAAL,WAAAoB,EAAAC,EAAAI,IAEF,IAAA5B,GAAAQ,EAAAR,MATC,IAAIoI,EAAWpI,EAAQiI,MAAgBG,EAAWpI,EAAQ,aAAemI,GAAkB,CAW7F,IAAOE,GAAPrI,EAAAiI,KAAA9G,EAAA,CAxBKkH,EAAArI,EAAAC,OAAAO,CAgBC,MAAM8H,IAAU,EAAG,CAY3B,SAKO,MAAAD,GAAA,IAAME,qBAAAA,QAAAA,oBAAsB,QAAtBA,GAAuB1E,EAAM1C,GAAP,MACjCM,QAAOD,KAAKgH,qBAAqB3E,EAAM1C,GAASmH,MAAO,KAAM,GAsBzDD,IAAOnC,qBAAAA,QAAAA,oBAAoBvG,QAApBuG,GAAoBvG,GAA4BgB,GAAjB8H,GAAiB9H,UAAAA,OAAAA,GAAAA,UAAAA,KAAAA,UAAAA,UAAAA,KAE1D,IAJD+H,GAAAR,EAAAQ,eAAA,IAHA,IAAML,KASN,IAAAM,GAAA7I,IAAAM,KAAA8H,EAAAS,UAAA,OANAA,GAAS,SAACnI,EAAMG,GAUlB,GAAAhB,WAAAqI,WAAArH,EAAAkH,GAAA,CARMQ,EAAOnC,KAAKwC,EAAe/I,WAAW8I,iBAAiB9H,EAAMkH,GAAUlH,KAI3E,OAAO0H,GAuBHpI,IAAOJ,YAAAA,QAAAA,WADT,QACSA,GADTA,EAAAuH,GAAA,GAIAtH,GAAAK,WAASyI,EAIX9I,KAAIM,GAAKiB,EAAWb,CAZlB,MAAOA,GAGTA,EAAO,GAAIV,KAAIC,SAgBfmB,MAASP,EADJS,KAAA,IAVHtB,IAAIM,KAAKwI,wBACT9I,IAAIM,KAAKgG,oBAGXtG,KAAIM,KAAKiB,WAAWb,EAEpB,OAAOA,GAIF,IAAMqI,OAAAA,QAAAA,MAAQ,QAARA,GAAQlI,GACnBO,SAASP,EAAM,WAAY,GAAImI","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/wiki.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport {\n  EnvironmentError,\n  InvalidArgumentException,\n}                           from '$:/plugins/felixhayashi/tiddlymap/js/exception';\nimport * as basicUtils      from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic';\n\n/**\n * Gets a tiddler reference from a tRef or tObj\n *\n * @param {Tiddler|string} tiddler - A tiddler reference or object.\n * @return {TiddlerReference|null} A tiddler reference (title)\n */\nexport const getTiddlerRef = tiddler => {\n\n  if (tiddler instanceof $tw.Tiddler) {\n\n    return tiddler.fields.title;\n\n  } else if (typeof tiddler === 'string') {\n\n    return tiddler;\n\n  } else {\n\n    throw new InvalidArgumentException(tiddler);\n\n  }\n\n};\n\n/**\n * Similar to {@code wiki.getTiddler()} but also accepts a tObj as\n * argument, thus, making it unnecessary to always differentiate or remember\n * if we are dealing with an object or a reference.\n *\n * @see https://github.com/Jermolene/TiddlyWiki5/blob/master/boot/boot.js#L866\n * @param {Tiddler} tiddler - A tiddler reference or object.\n * @return {Tiddler} A tiddler object.\n */\nexport const getTiddler = tiddler =>\n  $tw.wiki.getTiddler(tiddler instanceof $tw.Tiddler ? tiddler.fields.title : tiddler);\n\n/**\n * Get a tiddler's field value. If the field does not exist or\n * its value is an empty string, return the default or an empty\n * string.\n */\nexport const getField = (tiddler, field, defValue = '') => {\n\n  const tObj = getTiddler(tiddler);\n  return (!tObj ? defValue : tObj.fields[field] || defValue);\n\n};\n\n/**\n * Checks if tiddlers (including shadow tiddlers) exist.\n *\n * @param {Tiddler} tiddler\n * @return {boolean} True if the tiddler exists, false otherwise\n */\nexport const tiddlerExists = tiddler => {\n\n  if (!tiddler) {\n    return false;\n  }\n\n  const tRef = getTiddlerRef(tiddler);\n\n  return Boolean(tRef && ($tw.wiki.tiddlerExists(tRef) || $tw.wiki.isShadowTiddler(tRef)));\n\n};\n\nexport const setSidebarTab = tRef => {\n\n  setText(getTiddlersByPrefix('$:/state/tab/sidebar-')[0], tRef);\n\n};\n\n/**\n * Set a tiddler field to a given value.\n *\n * Setting the title field to another value will clone the tiddler.\n * In this case, better use @link{clone} as this is\n * semantically stronger.\n *\n * This method is guarded against\n * https://github.com/Jermolene/TiddlyWiki5/issues/2025\n *\n * @return {$tw.Tiddler|undefined} The tiddler object containing\n *     the field with the assigned value.\n */\nexport const setField = (tiddler, field, value) => {\n\n  if (!tiddler || !field) {\n    return;\n  }\n\n  const tRef = getTiddlerRef(tiddler);\n  const fields = {\n    title: tRef,\n    [field]: value\n  };\n\n  // do not use any tObj provided, it may result in a lost update!\n  let tObj = $tw.wiki.getTiddler(tRef, true);\n\n  if (field !== 'text' && tObj && !tObj.fields.text) {\n    fields.text = '';\n  }\n\n  tObj = new $tw.Tiddler(tObj, fields);\n  $tw.wiki.addTiddler(tObj);\n\n  return tObj;\n\n};\n\n/**\n * Pendant to tw native {@code addTiddlers()}.\n *\n * Also removes tiddlers from the river.\n *\n * @param {TiddlerCollection} tiddlers - A collection of tiddlers\n * to be removed.\n */\nexport const deleteTiddlers = tiddlers => {\n\n  const keys = Object.keys(tiddlers);\n  const storyList = $tw.wiki.getTiddlerList('$:/StoryList');\n\n  for (let i = keys.length; i--;) {\n    let tRef = getTiddlerRef(tiddlers[keys[i]]);\n    if (!$tw.wiki.tiddlerExists(tiddlers[keys[i]])) {\n      // this check is important!\n      // see https://github.com/Jermolene/TiddlyWiki5/issues/1919\n      continue;\n    }\n\n    const index = storyList.indexOf(tRef);\n    if (index !== -1) { // tiddler is displayed in river\n      storyList.splice(index, 1);\n      setField('$:/StoryList', 'list', storyList);\n    }\n\n    // finally delete the tiddler;\n\n\n    $tw.wiki.deleteTiddler(tRef);\n\n  }\n\n};\n\nexport const moveFieldValues = (oldName, newName, isRemoveOldField, isIncludeSystemTiddlers, tiddlers) => {\n\n  if (oldName === newName) return;\n\n  const allTiddlers = tiddlers || $tw.wiki.allTitles();\n\n  for (let i = allTiddlers.length; i--;) {\n\n    const tObj = getTiddler(allTiddlers[i]);\n\n    if (tObj.isDraft() || !tObj.fields[oldName]) {\n      continue;\n    }\n\n    if (!isIncludeSystemTiddlers && $tw.wiki.isSystemTiddler(allTiddlers[i])) {\n      continue;\n    }\n\n    const fields = {\n      [newName]: tObj.fields[oldName]\n    };\n\n    if (isRemoveOldField) {\n      fields[oldName] = undefined;\n    }\n    $tw.wiki.addTiddler(new $tw.Tiddler(tObj, fields));\n\n  }\n\n};\n\n/**\n * This function facilitates to check whether a list of tiddlers\n * matches a certain filter. If the tiddler does not exist, it is not\n * returned as match. If no list is specified, all tiddlers in\n * the wiki are considered.\n *\n * @Todo: skip drafts! Or not?\n *\n * @param {TiddlyWikiFilter} filter - The filter to use.\n * @param {TiddlerCollection} [tiddlers] - A set of tiddlers used as\n *     source. If not defined, all tiddlers and system tiddlers are\n *     selected. Shadows are *not* included.\n * @return {Array.<TiddlerReference>}\n */\nexport const getMatches = (filter, tiddlers) => {\n\n  // use wiki as default source\n  let source = undefined;\n\n  // shortcuts for performance\n  const wiki = $tw.wiki;\n\n  if (typeof filter === 'string') {\n    filter = wiki.compileFilter(filter);\n  }\n\n  // if a source is provided, create an iterator callback\n  if (tiddlers != null && typeof tiddlers === 'object') {\n\n    if (!Array.isArray(tiddlers)) {\n      tiddlers = Object.keys(tiddlers);\n    }\n\n    source = callback => {\n      for (let i = tiddlers.length; i--;) {\n        const tObj = wiki.getTiddler(tiddlers[i]);\n        callback(tObj, tiddlers[i]);\n      }\n    };\n\n  }\n\n  return filter.call(wiki, source);\n\n};\n\n/**\n * Tries to match a single tiddler object against a filter.\n * Returns a boolean value.\n *\n * @param {Tiddler} tiddler - The object to apply the filter to.\n * @param {TiddlyWikiFilter} filter - The filter to use.\n * @return {boolean} True if the tiddler matches the filter, false otherwise.\n */\nexport const isMatch = (tiddler, filter) =>\n  getTiddlerRef(tiddler) === getMatches(filter, [ getTiddlerRef(tiddler) ])[0];\n\n\n/**\n *\n * @param {Tiddler} tiddler\n * @param {boolean} isBlock\n */\nexport const getTranscludeNode = (tiddler, isBlock) =>\n  ({\n    type: 'transclude',\n    attributes: {\n      tiddler: {\n        type: 'string',\n        value: getTiddlerRef(tiddler) }},\n    children: [],\n    isBlock: !!isBlock\n  });\n\n/**\n *\n * @param {Tiddler} tiddler\n */\nexport const getTiddlerNode = tiddler =>\n  ({\n    type: 'tiddler',\n    attributes: {\n      tiddler: {\n        type: 'string', value: getTiddlerRef(tiddler) }},\n    children: []\n  });\n\n/**\n *\n * @param type\n * @param className\n * @param text\n */\nexport const getElementNode = (type, className, text) =>\n  ({\n    type: 'element',\n    tag: type,\n    attributes: {\n      class: {\n        type: 'string',\n        value: className }},\n    children: text ? [ {type: 'text', text: text } ] : []\n  });\n\n/**\n *\n * @param {Widget} widget\n * @param {string} name\n * @param {Tiddler} tiddler\n * @return {*}\n */\nexport const registerTransclude = (widget, name, tiddler) => {\n\n  // if an instance exists, remove it\n  basicUtils.removeArrayElement(widget.children, widget[name]);\n\n  widget[name] = widget.makeChildWidget(getTranscludeNode(tiddler, true));\n  widget.children.push(widget[name]);\n\n  return widget[name];\n\n};\n\n/**\n * This function uses the tw-notification mechanism to display a\n * temporary message.\n *\n * @see https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/dom/notifier.js\n * @param {string} message - A short message to display.\n */\nexport const notify = message => {\n\n  // @todo add to environment\n  const notifyTiddlerRef = '$:/temp/tiddlymap/notify';\n\n  $tw.wiki.addTiddler(new $tw.Tiddler({\n    title : notifyTiddlerRef,\n    text : message\n  }));\n\n  $tw.notifier.display(notifyTiddlerRef);\n\n};\n\n/**\n * The function allows to detect whether a widget is displayed\n * in preview or not.\n */\nexport const isPreviewed = widget => {\n\n  if (!widget) {\n    return false;\n  }\n\n  if (widget.getVariable('tv-tiddler-preview')) {\n    return true;\n  } else { // fallback for < v5.1.9\n    const cls = 'tc-tiddler-preview-preview';\n    return !!basicUtils.getAncestorWithClass(widget.parentDomNode, cls);\n  }\n\n};\n\n/**\n * Parse json from field or return default value on error.\n *\n * @param {Tiddler} tiddler - The tiddler containing the json.\n * @param {string} field - The field with the json data.\n * @param {Object} [data] - An optional default value.\n * @return {*} Either the parsed data or the default data.\n */\nexport const parseFieldData = (tiddler, field = 'text', data) => {\n\n  const tObj = getTiddler(tiddler);\n\n  if (!tObj) {\n    return data;\n  }\n\n  return basicUtils.parseJSON(tObj.fields[field], data);\n\n};\n\n/**\n * Serialize json data and store it in a tiddler's field.\n *\n * @param {Tiddler} tiddler - The tiddler to store the json in.\n * @param {string} field - The field that will store the json.\n * @param {Object} data - The json data.\n * @param {int} [indent = 0] - the indentation\n */\nexport const writeFieldData = (tiddler, field, data, indent) => {\n\n  if (typeof data !== 'object') {\n    return;\n  }\n\n  indent = parseInt(indent);\n  indent = (indent > 0 && field === 'text' ? indent : 0);\n\n  setField(tiddler, field, JSON.stringify(data, null, indent));\n\n};\n\n/**\n * Clone a tiddler and give it another title.\n * This means the tiddlers are equal except from their titles.\n */\nexport const clone = (src, dest) => {\n\n  setField(src, 'title', dest);\n\n};\n\n/**\n * Set the value of a data tiddler entry (index) to a given value\n */\nexport const setEntry = (tiddler, prop, value) => {\n\n  $tw.wiki.setText(getTiddlerRef(tiddler), null, prop, value);\n\n};\n\n/**\n * Get the value of a data tiddler entry (index)\n */\nexport const getEntry = (tiddler, prop, defValue) => {\n\n  const data = $tw.wiki.getTiddlerData(getTiddlerRef(tiddler), {});\n  return (data[prop] == null ? defValue : data[prop]);\n\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n  //~ propPath = propPath.split(\".\");\n  //~ for (var i = propPath.length; i--;) {\n    //~ if (obj !== null && typeof obj === \"object\") {\n      //~ obj = obj[propPath[i]];\n  //~ }\n  //~\n//~ };\n\n/**\n * Compare versions.\n * @return {boolean} Unlike `$tw.utils.checkVersions`, this function\n * only returns true if the left argument is greater than the right\n * argument.\n */\nexport const isLeftVersionGreater = (v1, v2) => v1 !== v2 && $tw.utils.checkVersions(v1, v2);\n\n/**\n *\n * @param tiddler\n * @param defValue\n */\nexport const getText = (tiddler, defValue) => getField(tiddler, 'text', defValue);\n\n/**\n *\n * @param tiddler\n * @param value\n */\nexport const setText = (tiddler, value) => {\n\n  setField(tiddler, 'text', value);\n\n};\n\n/**\n * Checks whether a tiddler is a draft or not.\n *\n * @param {Tiddler} tiddler - The tiddler to check on.\n */\nexport const isDraft = tiddler => {\n\n  const tObj = getTiddler(tiddler);\n  return (tObj && tObj.isDraft());\n\n};\n\n\n/**\n * Get a tiddler's text or otherwise return a default text.\n */\nexport const isSystemOrDraft = tiddler =>\n  $tw.wiki.isSystemTiddler(getTiddlerRef(tiddler)) || isDraft(tiddler);\n\n/**\n * Function to merge an array of tiddlers into a single tiddler.\n *\n * @param {Array<TiddlerReference|Tiddler>} tiddlers - The\n *     tiddlers to merge.\n * @param {string} [title=null] - The title where the result is\n *     written to. If not specified, the first array item is used\n *     as output title.\n */\nexport const getMergedTiddlers = (tiddlers, title) => {\n\n  if (!Array.isArray(tiddlers)) {\n    return;\n  }\n\n  // turn all array elements into tiddler objects\n  for (let i = tiddlers.length; i--;) {\n    tiddlers[i] = getTiddler(tiddlers[i]);\n  }\n\n  if (!tiddlers.length) {\n    return;\n  }\n\n  tiddlers.push(\n    { title: (title || tiddlers[0].fields.title) },\n    $tw.wiki.getModificationFields(),\n    $tw.wiki.getCreationFields()\n  );\n\n  // add context for `apply()` function\n  tiddlers.unshift(null);\n\n  return new (Function.prototype.bind.apply($tw.Tiddler, tiddlers));\n\n};\n\n/**\n * Depth first search\n */\nexport const getChildWidgetByProperty = (widget, prop, val) => {\n\n  const children = widget.children;\n  for (let i = children.length; i--;) {\n    let child = children[i];\n    if (child[prop] === val) {\n      return child;\n    } else {\n      child = getChildWidgetByProperty(child, prop, val);\n      if (child) {\n        return child;\n      }\n    }\n  }\n\n};\n\n/**\n * Register listeners to widget using a hashmap.\n *\n * @param {Hashmap<Key, Function>} listeners - The listeners to attach.\n * @param {Widget} widget - the widget to attach the listeners to.\n * @param {Object} context - The context to bind the listeners to.\n */\nexport const addTWlisteners = (listeners, widget, context) => {\n\n  for (let id in listeners) {\n    widget.addEventListener(id, listeners[id].bind(context));\n  }\n\n};\n\n/**\n * Renames all tiddler titles that are prefixed with `oldPrefix`\n * into titles that are prefixed with `newPrefix` by replacing\n * `oldPrefix` with `newPrefix`.\n *\n * The force option somewhat ensures atomicity.\n *\n * @param {string} oldPrefix - Moves all tiddlers with this prefix.\n * @param {string} newPrefix - All tiddlers moved tiddlers will\n *     receive this new prefix.\n * @param {boolean} [isForce=false] - If a new title would override\n *     an existing title, and `force` is not set, then nothing will\n *     happen and undefined is returned by the function.\n * @param {boolean} [isDelete=true] - True, if the tiddlers with the\n *     old prefix should be deleted or false, if they should be kept.\n * @returns {Object<string, string>} - A hashmap that maps the old\n *     and the new path.\n */\nexport const mv = (oldPrefix, newPrefix, isForce, isDelete) => {\n\n  if (oldPrefix === newPrefix || !oldPrefix || !newPrefix) {\n    return;\n  }\n\n  isForce = (typeof isForce === 'boolean' ? isForce : false);\n  isDelete = (typeof isDelete === 'boolean' ? isDelete : true);\n\n  // prepare\n  const targets = getTiddlersByPrefix(oldPrefix);\n  const fromToMapper = basicUtils.makeHashMap();\n\n  for (let i = targets.length; i--;) {\n\n    const oldTRef = targets[i];\n    const newTRef = oldTRef.replace(oldPrefix, newPrefix);\n    if ($tw.wiki.tiddlerExists(newTRef) && !isForce) {\n      return; // undefined\n    }\n    fromToMapper[oldTRef] = newTRef;\n\n  }\n\n  for (let oldTRef in fromToMapper) {\n\n    setField(oldTRef, 'title', fromToMapper[oldTRef]);\n    if (isDelete) {\n      $tw.wiki.deleteTiddler(oldTRef);\n    }\n  }\n\n  return fromToMapper;\n\n};\n\n/**\n * Clones all tiddler titles that are prefixed with `oldPrefix`\n * into titles that are instead prefixed with `newPrefix`.\n *\n * The force option somewhat ensures atomicity.\n *\n * @param {string} oldPrefix - Moves all tiddlers with this prefix.\n * @param {string} newPrefix - All tiddlers moved tiddlers will\n *     receive this new prefix.\n * @param {boolean} [isForce=false] - If a new title would override\n *     an existing title, and `force` is not set, then nothing will\n *     happen and undefined is returned by the function.\n * @returns {Object<string, string>} - A hashmap that maps the old\n *     and the new path.\n */\nexport const cp = (oldPrefix, newPrefix, isForce) =>\n  mv(oldPrefix, newPrefix, isForce, false);\n\n/**\n * Delete all tiddlers with a given prefix.\n *\n * @param {string} prefix - The prefix\n */\nexport const deleteByPrefix = (prefix, tiddlers) => {\n\n  if (!prefix) {\n    return;\n  }\n\n  tiddlers = tiddlers || $tw.wiki.allTitles();\n\n  const deletedTiddlers = [];\n  for (let i = tiddlers.length; i--;) {\n    if (basicUtils.startsWith(tiddlers[i], prefix)) {\n      $tw.wiki.deleteTiddler(tiddlers[i]);\n      deletedTiddlers.push(deletedTiddlers[i]);\n    }\n  }\n\n  return deletedTiddlers;\n\n};\n\n\n/**\n * Returns all tiddlers that possess a property with a certain value.\n *\n * @param {string} fieldName - The property name to look for.\n * @param {string} [value] - If provided, the field's value must\n *     equal this value in order to match.\n * @param {Hashmap} [options] - Further options.\n * @param {TiddlerCollection} [options.tiddlers=$tw.wiki.allTitles()] - A collection\n *     of tiddlers to perform the search on.\n * @param {boolean} [options.isIncludeDrafts=false] - True if drafts of the found\n *     tiddlers are also included in the result set.\n * @param {number} [options.limit] - A positive number delimiting the maximum\n *     number of results.\n *     tiddlers are also included in the result set.\n * @return {Hashmap.<TiddlerReference, Tiddler>} Result\n */\nexport const getTiddlersWithField = (fieldName, value, options = {}) => {\n\n  const tiddlers = options.tiddlers || $tw.wiki.allTitles();\n  const isIncludeDrafts = (options.isIncludeDrafts === true);\n  const result = basicUtils.makeHashMap();\n  const keys = Object.keys(tiddlers);\n  const hasOwnProp = $tw.utils.hop;\n  let limit = options.limit || 0;\n\n  for (let i = keys.length; i--;) {\n\n    const tObj = getTiddler(tiddlers[keys[i]]);\n    const fields = tObj.fields;\n    if (hasOwnProp(fields, fieldName) && (!hasOwnProp(fields, 'draft.of') || isIncludeDrafts)) {\n      if (!value || fields[fieldName] === value ) {\n        result[fields.title] = tObj;\n        if (--limit === 0) {\n          break;\n        }\n      }\n    }\n\n  }\n\n  return result;\n\n};\n\n/**\n *\n * @param name\n * @param value\n */\nexport const getTiddlerWithField = (name, value) =>\n  Object.keys(getTiddlersWithField(name, value, { limit: 1 }))[0];\n\n/**\n * Iterates over all tiddlers in a given way and returns tiddlers\n * whose title matches the prefix string.\n *\n * @param {string} prefix - The prefix to match\n * @param {Hashmap} [options] - An options object.\n * @param {string} [options.iterator=\"each\"] - A tw store iterator\n *    function, e.g. \"eachShadow\" or \"ShadowPlusTiddlers\".\n * @param {boolean} [options.removePrefix= false] - Whether to remove\n *     the prefix or to leave it.\n * @return {Array<string>} The matches with or without the prefix.\n */\nexport const getTiddlersByPrefix = (prefix, options = {}) => {\n\n  const removePrefix = (options.removePrefix === true);\n  const result = [];\n  const iterator = $tw.wiki[options.iterator || 'each'];\n\n  iterator((tObj, tRef) => {\n    if (basicUtils.startsWith(tRef, prefix)) {\n      result.push(removePrefix ? basicUtils.getWithoutPrefix(tRef, prefix) : tRef);\n    }\n  });\n\n  return result;\n\n};\n\n/**\n * Advanced addTiddler method.\n *\n * It adds timestamps and only adds the tiddler if it doesn't exist\n * yet or the force option is used.\n *\n * This method is guarded against\n * https://github.com/Jermolene/TiddlyWiki5/issues/2025\n */\nexport const addTiddler = (tiddler, isForce) => {\n\n  let tObj = getTiddler(tiddler);\n\n  if (!isForce && tObj) {\n    return tObj;\n  }\n\n  tObj = new $tw.Tiddler(\n    {\n      title: tiddler,\n      text: ''\n    },\n    $tw.wiki.getModificationFields(),\n    $tw.wiki.getCreationFields()\n  );\n\n  $tw.wiki.addTiddler(tObj);\n\n  return tObj;\n\n};\n\nexport const touch = tRef => {\n  setField(tRef, 'modified', new Date());\n};\n"],"sourceRoot":"../../../../../../../src/plugins"}