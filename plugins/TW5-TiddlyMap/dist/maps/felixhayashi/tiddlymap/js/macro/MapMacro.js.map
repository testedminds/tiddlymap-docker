{"version":3,"sources":["felixhayashi/tiddlymap/js/macro/MapMacro.js"],"names":["_EdgeType","require","_ViewAbstraction","_utils","name","params","getParamSlots","run","this","substVarRefs","substituteVariableReferences","fn","command","arguments","result","args","Array","prototype","slice","call","apply","arr","i","maxArgs","_utils2","default","makeHashMap","basename","separator","str","getVariable","getBasename","datauri","tiddler","type","getDataUri","fieldName","tObj","$tw","wiki","getTiddler","JSON","parse","fields","SyntaxError","testJSON","index","split","concat","splitAndSelect","length","l","uuid","genUUID","regRepl","oldStr","regStr","regFlags","replace","RegExp","newStr","halfOfString","Math","ceil","view","userInput","_ViewAbstraction2","id","substr","getETyId","isEdgeTypeVisible","_EdgeType2","getInstance","_EdgeType$getIdParts","getIdParts","marker","namespace","getConfig","getId","parseInt","scale","prefix","option","path","unit","prop","$tm","propertyPath","hasSubString","lastIndexOf"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/macro/MapMacro.js","sourcesContent":["// @preserve\n/*\\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/macro/tmap\ntype: application/javascript\nmodule-type: macro\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport EdgeType        from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport ViewAbstraction from '$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction';\nimport utils           from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/*** Code **********************************************************/\n\nconst name = 'tmap';\nconst params = getParamSlots(5);\n\n/**\n * @this MacroCallWidget\n * @return {string} the result of the operation or an empty string.\n * @private\n */\nfunction run() {\n\n  this.substVarRefs = this.substituteVariableReferences;\n\n  const fn = command[arguments[0]];\n  let result = null;\n\n  if (typeof fn === 'function') {\n    const args = Array.prototype.slice.call(arguments,1);\n    result = fn.apply(this, args);\n  }\n\n  return (typeof result === 'string' ? result : '');\n\n}\n\n/**\n * unfortunately tw forces us to specify params in advance so I\n * will reserve some argument slots here.\n * @private\n */\nfunction getParamSlots(maxArgs) {\n\n  const arr = [];\n  for (let i = 0; i < maxArgs; i++) {\n    arr.push({ name : ('arg' + i) });\n  }\n\n  return arr;\n\n}\n\n/**\n * In connection with tiddlymap, this macro allows us to access\n * system information from within tiddlers as well as to execute\n * some util functions.\n *\n * Every command will be called with `this` pointing to the current\n * MacroCallWidget instance!\n *\n * @private\n */\nvar command = utils.makeHashMap();\n\n/**\n * Returns the basename of the string\n *\n * @see {@link utils.basename}\n */\ncommand.basename = function(separator) {\n\n  var str = this.getVariable('currentTiddler');\n  return utils.getBasename(str, separator);\n\n};\n\n/**\n * TW messes with svg urls so we always use base64 encoding when\n * a data uri is requested as macro call\n */\ncommand.datauri = function(tiddler, type) {\n\n  return utils.getDataUri(tiddler, type, true);\n\n};\n\ncommand.testJSON = function(fieldName) {\n\n  var tObj = $tw.wiki.getTiddler(this.getVariable('currentTiddler'));\n\n  try {\n    JSON.parse(tObj.fields[fieldName]);\n    return 'valid';\n  } catch (SyntaxError) {\n    return 'malformed';\n  }\n\n};\n\ncommand.splitAndSelect = function(separator, index) {\n\n  var str = this.getVariable('currentTiddler');\n  var result = str.split(separator)[index];\n\n  return (result != null ? result : str);\n\n};\n\ncommand.concat = function() {\n\n  var str = '';\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    str += arguments[i];\n  }\n  return str;\n\n};\n\ncommand.uuid = function() {\n\n  return utils.genUUID();\n\n};\n\ncommand.regRepl = function() {\n\n  var oldStr = this.substVarRefs(arguments[0]);\n  var regStr = arguments[1];\n  var newStr = this.substVarRefs(arguments[2]);\n  var regFlags = this.substVarRefs(arguments[4]);\n\n  return oldStr.replace(new RegExp(regStr, regFlags), newStr);\n\n};\n\ncommand.halfOfString = function() {\n\n  var str = this.substVarRefs(arguments[0]);\n\n  if (!str) {\n    return '';\n  }\n\n  return str.substr(0, Math.ceil(str.length / 2));\n\n};\n\ncommand.isETyVisible = function(view, userInput) {\n\n  view = new ViewAbstraction(view);\n\n  const id = command.getETyId.call(this, view, userInput);\n\n  return '' + view.isEdgeTypeVisible(id);\n\n};\n\ncommand.getETyId = function(view, userInput) {\n\n  view = new ViewAbstraction(view);\n\n  let type = EdgeType.getInstance(userInput || this.getVariable('currentTiddler'));\n\n  if (!type.namespace) {\n\n    const { marker, name } = EdgeType.getIdParts(type.id);\n    const namespace = view.getConfig('edge_type_namespace');\n\n    type = EdgeType.getInstance(EdgeType.getId(marker, namespace, name));\n\n  }\n\n  return type.id;\n\n};\n\ncommand.scale = function() {\n\n  var str = '';\n  for (var i = 1, l = parseInt(arguments[0]); i < l; i++) {\n    str += '[[' + i + ']]';\n  }\n  return str;\n\n};\n\ncommand.mergeFields = function() {\n\n  var tObj = utils.getTiddler(arguments[0]);\n  var prefix = arguments[1];\n  var separator = arguments[2] || ' ';\n\n  if (!tObj) return;\n\n  var fields = utils.getPropertiesByPrefix(tObj.fields, prefix);\n  var str = '';\n  for (var name in fields) {\n\n    if (typeof fields[name] === 'string') {\n\n      str += fields[name] + separator;\n    }\n  }\n  return str;\n\n};\n\ncommand.option = function(path, unit) {\n\n  var prop = $tm;\n  var propertyPath = path.split('.');\n\n  for (var i = 0; i < propertyPath.length; i++) {\n    if (typeof prop == 'object' && prop[propertyPath[i]]) {\n      prop = prop[propertyPath[i]];\n    }\n  }\n\n  // TODO: ugly, use regex\n  if (unit && typeof prop === 'string'\n     && utils.hasSubString(unit)\n     && (prop.lastIndexOf(unit) + unit.length) === prop.length) {\n    prop = prop + unit;\n  }\n\n  return prop;\n\n};\n\n/*** Exports *******************************************************/\n\nexport { run, name, params };\n"],"sourceRoot":"../../../../../../src/plugins"}