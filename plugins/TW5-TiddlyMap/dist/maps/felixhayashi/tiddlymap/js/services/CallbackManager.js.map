{"version":3,"sources":["felixhayashi/tiddlymap/js/services/CallbackManager.js"],"names":["_utils","require","CallbackManager","_classCallCheck","this","callbacks","_utils2","default","makeHashMap","logger","$tm","wiki","$tw","tRef","callback","isDeleteOnCall","arguments","length","undefined","execute","refOrRefList","i","changedTiddlers","getTiddler","remove"],"mappings":";;;;;;;;;;AAWA,GAAAA,QAAAC,QAAA,kRAKMC,4BAEJ,QAAAA,KAAcC,gBAAAC,KAAAF,EACZE,MAAKC,UAAYC,QAAAC,QAAMC,aACvBJ,MAAKK,OAASC,IAAID,MAClBL,MAAKO,KAAOC,IAAID,iDAedE,EAAMC,GAAiC,GAAvBC,GAAuBC,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAN,IAEnCZ,MAAKK,OAAO,QAAZ,6CAAkEI,EAAlE,IACAT,MAAKC,UAAUQ,IACbM,QAASL,EACTC,eAAAA,oCAQGK,GAEL,IAAKA,EAAc,CACjB,OAGF,SAAWA,KAAiB,SAAU,CACpCA,GAAiBA,GAhBjBD,IAAAA,GAAAA,GAASL,EADYG,OAAAI,KAAA,CAErBN,GAAAA,GAAAA,EAAAA,EAFqB,IAAvBX,KAAAC,UAAAQ,GAAA,CAKDT,KAAAK,OAAA,QAAA,0BAAAI,EAAA,WAmBYT,MAAKC,UAAUQ,uCARtBS,GAEH,GAAAlB,KAAAC,UAAAY,QAAA,EAAA,CAsBC,OAlBA,IAAA,GAAIJ,KAAKR,GAAiB,CAExB,IAAAD,KAAAC,UAAYA,GAAUQ,CACvB,SAwBD,GAAIT,KAAKO,KAAKY,WAAWV,GAAO,CAE9BT,KAAKK,OAAO,QAAZ,6BAAkDI,EAClDT,MAAKC,UAAUQ,GAAMM,QAAQN,EAG7B,KAAKT,KAAKC,UAAUU,eAAgB,CAClC,UAIJX,KAAKoB,OAAOX,oCAfPX","file":"../../../../../felixhayashi/tiddlymap/js/services/CallbackManager.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/CallbackManager\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/**\n * Makes it possible to register callbacks for tiddler changes.\n */\nclass CallbackManager {\n\n  constructor() {\n    this.callbacks = utils.makeHashMap();\n    this.logger = $tm.logger;\n    this.wiki = $tw.wiki;\n  }\n\n  /**\n   * The callback mechanism allows to dynamically listen to tiddler\n   * changes without hardcoding a change-check for a tiddler name\n   * in the refresh function.\n   *\n   * @param {TiddlerReference} tRef - A tiddler whose change triggers\n   *     the callback.\n   * @param {function} callback - A function that is called when the\n   *     tiddler has changed.\n   * @param {boolean} [isDeleteOnCall=true] - True if to delete the\n   *     callback once it has been called, false otherwise.\n   */\n  add(tRef, callback, isDeleteOnCall = true) {\n\n    this.logger('debug', `A callback was registered for changes of \"${tRef}\"`);\n    this.callbacks[tRef] = {\n      execute: callback,\n      isDeleteOnCall\n    };\n\n  };\n\n  /**\n   * Removes the callback from the list of tiddler callbacks.\n   */\n  remove(refOrRefList) {\n\n    if (!refOrRefList) {\n      return;\n    }\n\n    if (typeof refOrRefList === 'string') {\n      refOrRefList = [ refOrRefList ];\n    }\n\n    for (let i = refOrRefList.length; i--;) {\n      const tRef = refOrRefList[i];\n      if (this.callbacks[tRef]) {\n        this.logger('debug', `Deleting callback for \"${tRef}\"`);\n        delete this.callbacks[tRef];\n      }\n    }\n\n  };\n\n  /**\n   * this method has to be implemented at the top of the refresh method.\n   * It checks for changed tiddlers that have\n   * registered callbacks. If `deleteOnCall` was specified during\n   * registration of the callback, the callback will be deleted\n   * automatically.\n   */\n  refresh(changedTiddlers) {\n\n    if (this.callbacks.length == 0) {\n      return;\n    }\n\n    for (let tRef in changedTiddlers) {\n\n      if (!this.callbacks[tRef]) {\n        continue;\n      }\n\n      if (this.wiki.getTiddler(tRef)) {\n\n        this.logger('debug', `Executing a callback for: ${tRef}`);\n        this.callbacks[tRef].execute(tRef);\n\n        // a continue prevents deleting the callback\n        if (!this.callbacks.isDeleteOnCall) {\n          continue;\n        }\n      }\n\n      this.remove(tRef);\n    }\n\n  };\n}\n\n/*** Exports *******************************************************/\n\nexport default CallbackManager;\n"],"sourceRoot":"../../../../../../src/plugins"}